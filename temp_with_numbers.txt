    1: package woflo.petsplus.state.emotions;
    2: 
    3: import com.google.gson.JsonElement;
    4: import com.google.gson.JsonObject;
    5: import net.minecraft.block.BlockState;
    6: import net.minecraft.block.Blocks;
    7: import net.minecraft.block.CampfireBlock;
    8: import net.minecraft.block.RespawnAnchorBlock;
    9: import net.minecraft.component.DataComponentTypes;
   10: import net.minecraft.component.type.ItemEnchantmentsComponent;
   11: import net.minecraft.enchantment.Enchantment;
   12: import net.minecraft.entity.EquipmentSlot;
   13: import net.minecraft.entity.LivingEntity;
   14: import net.minecraft.entity.effect.StatusEffect;
   15: import net.minecraft.entity.effect.StatusEffectCategory;
   16: import net.minecraft.entity.effect.StatusEffectInstance;
   17: import net.minecraft.entity.effect.StatusEffects;
   18: import net.minecraft.entity.mob.MobEntity;
   19: import net.minecraft.entity.player.PlayerEntity;
   20: import net.minecraft.item.ItemStack;
   21: import net.minecraft.nbt.NbtCompound;
   22: import net.minecraft.registry.Registries;
   23: import net.minecraft.registry.entry.RegistryEntry;
   24: import net.minecraft.registry.tag.BiomeTags;
   25: import net.minecraft.registry.tag.FluidTags;
   26: import net.minecraft.server.world.ServerWorld;
   27: import net.minecraft.block.entity.BlockEntity;
   28: import net.minecraft.block.entity.BlockEntityType;
   29: import net.minecraft.text.MutableText;
   30: import net.minecraft.text.Text;
   31: import net.minecraft.text.TextColor;
   32: import net.minecraft.util.Formatting;
   33: import net.minecraft.util.Identifier;
   34: import net.minecraft.util.math.BlockPos;
   35: import net.minecraft.util.math.ChunkSectionPos;
   36: import net.minecraft.util.math.MathHelper;
   37: import net.minecraft.util.math.Direction;
   38: import net.minecraft.util.math.Vec3d;
   39: import net.minecraft.world.World;
   40: import net.minecraft.world.biome.Biome;
   41: import net.minecraft.world.biome.BiomeKeys;
   42: import org.jetbrains.annotations.Nullable;
   43: import woflo.petsplus.api.registry.PetRoleType;
   44: import woflo.petsplus.api.registry.RegistryJsonHelper;
   45: import woflo.petsplus.config.MoodEngineConfig;
   46: import woflo.petsplus.config.PetsPlusConfig;
   47: import woflo.petsplus.state.OwnerCombatState;
   48: import woflo.petsplus.state.PetComponent;
   49: import woflo.petsplus.state.StateManager;
   50: import woflo.petsplus.state.coordination.PetSwarmIndex;
   51: import woflo.petsplus.ui.UIStyle;
   52: 
   53: import java.util.ArrayDeque;
   54: import java.util.ArrayList;
   55: import java.util.Arrays;
   56: import java.util.Collections;
   57: import java.util.Comparator;
   58: import java.util.EnumMap;
   59: import java.util.EnumSet;
   60: import java.util.HashMap;
   61: import java.util.List;
   62: import java.util.Map;
   63: import java.util.Optional;
   64: import java.util.concurrent.ConcurrentHashMap;
   65: import java.util.concurrent.ConcurrentMap;
   66: import java.util.stream.Collectors;
   67: import java.lang.reflect.Field;
   68: import java.lang.reflect.Method;
   69: import java.lang.ReflectiveOperationException;
   70: 
   71: /**
   72:  * Sophisticated emotional intelligence system for Minecraft pets that creates realistic,
   73:  * personality-driven emotional responses and mood dynamics.
   74:  *
   75:  * <h2>System Architecture</h2>
   76:  * <p>The engine implements a multi-layered emotional model:</p>
   77:  * <ul>
   78:  *   <li><b>Emotion Layer:</b> Lightweight records tracking intensity, impact, cadence, volatility,
   79:  *       and contextual modulation for each active emotion (e.g., CHEERFUL, ANGST, SAUDADE)</li>
   80:  *   <li><b>Mood Layer:</b> Weighted blends of emotions mapped to observable moods (e.g., HAPPY,
   81:  *       PROTECTIVE, YUGEN) with smooth transitions and momentum-based stabilization</li>
   82:  *   <li><b>Nature Integration:</b> Pet personality traits (from Natures like Timid, Bold, Calm)
   83:  *       modulate stimulus response, decay rates, habituation, and emotional expression</li>
   84:  *   <li><b>Context Awareness:</b> Bond strength, danger proximity, health status, and ongoing
   85:  *       conditions dynamically adjust emotional weights for situational realism</li>
   86:  * </ul>
   87:  *
   88:  * <h2>Psychological Realism Features</h2>
   89:  * <ul>
   90:  *   <li><b>Habituation & Sensitization:</b> Repeated stimuli reduce sensitivity (habituation),
   91:  *       while breaks re-sensitize pets to those emotions</li>
   92:  *   <li><b>Negativity Bias:</b> Negative emotions (fear, regret) persist 2-3x longer than positive
   93:  *       ones, mirroring real psychological threat-memory bias</li>
   94:  *   <li><b>Condition-Aware Decay:</b> Emotions decay slower when triggering conditions remain
   95:  *       (e.g., loneliness persists while owner is absent)</li>
   96:  *   <li><b>Opponent Dynamics:</b> Conflicting emotions (joy vs sadness) suppress each other with
   97:  *       nature-modulated transfer rates and resilience-based rebounds</li>
   98:  *   <li><b>Adaptive Momentum:</b> Fresh spikes switch moods fast (responsive), persistent states
   99:  *       drift slowly (stable), preventing emotional whiplash</li>
  100:  *   <li><b>Buildup & Hysteresis:</b> Progressive resistance to level increases (must "earn" higher
  101:  *       intensity), easier descent (smooth emotional release)</li>
  102:  * </ul>
  103:  *
  104:  * <h2>Performance Optimizations</h2>
  105:  * <ul>
  106:  *   <li>Incremental level history tracking with O(1) amortized updates</li>
  107:  *   <li>Quickselect for O(n) quantile calculations vs O(n log n) sorting</li>
  108:  *   <li>Lazy config caching with generation tracking to avoid redundant parsing</li>
  109:  *   <li>Smart update scheduling based on next emotion decay estimate</li>
  110:  * </ul>
  111:  *
  112:  * <p>The result: Minecraft pets that feel alive, remember past experiences, develop unique
  113:  * personalities, and respond authentically to their emotional journey with their owner.</p>
  114:  */
  116:     private static final float EPSILON = 0.01f;
  117:     private static final float DEFAULT_INTENSITY = 0f;
  118:     private static final float DEFAULT_IMPACT_CAP = 4.0f;
  119:     private static final float DEFAULT_WEIGHT_CAP = 6.0f;
  120:     private static final float CADENCE_ALPHA = 0.35f;
  121:     private static final float VOLATILITY_ALPHA = 0.25f;
  122:     private static final float PEAK_ALPHA = 0.18f;
  123:     private static final float HABITUATION_BASE = 1200f;
  124:     private static final float HALF_LIFE_MULTIPLIER = 1.35f;
  125:     private static final float MIN_HALF_LIFE = 400f;
  126:     private static final float MAX_HALF_LIFE = 3600f;
  127:     private static final float HOMEOSTASIS_RECOVERY_HALF = 2400f;
  128:     private static final float RELATIONSHIP_BASE = 1.0f;
  129:     private static final float DANGER_BASE = 1.0f;
  130:     private static final float APPRAISAL_BASE = 0.85f;
  131:     // Novelty parameters for future emotional dynamics
  132:     // private static final float NOVELTY_MIN = 0.05f;
  133:     // private static final float NOVELTY_MAX = 0.35f;
  134:     // private static final float NOVELTY_HALF_LIFE_FRACTION = 0.65f;
  135:     private static final int MOMENTUM_HISTORY_SIZE = 10;
  136:     private static final float OPPONENT_TRANSFER_MAX = 0.20f; // Phase 2 tuning
  137:     private static final float REBOUND_GAIN = 0.12f; // Phase 2 tuning
  138:     private static final float RELATIONSHIP_VARIANCE = 2200f;
  139:     private static final float CARE_PULSE_HALF_LIFE = 3600f;
  140:     private static final float DANGER_HALF_LIFE = 1200f;
  141:     
  142:     // Emotional buildup & level transition system
  143:     private static final int LEVEL_HISTORY_SIZE = 30;  // Track ~600 ticks (30 seconds)
  144:     private static final float BUILDUP_RISING_MULTIPLIER = 1.2f;
  145:     private static final float BUILDUP_FALLING_MULTIPLIER = 0.85f;
  146:     private static final float BUILDUP_TREND_THRESHOLD = 0.05f;
  147: 
  152:         EquipmentSlot.HEAD,
  153:         EquipmentSlot.CHEST,
  154:         EquipmentSlot.LEGS,
  155:         EquipmentSlot.FEET
  157: 
  158:     /**
  159:      * Authored default emotion-to-mood mapping derived from the narrative clusters described in the
  160:      * impact-weighted mood story. Each entry intentionally highlights the moods that should dominate
  161:      * when the corresponding emotion is active so config-less installations still surface expressive
  162:      * behaviour designers expect. The values are normalised so maintainers can audit or tweak the
  163:      * blend coefficients without hunting through code paths.
  164:      */
  165:     private static final EnumMap<PetComponent.Emotion, EnumMap<PetComponent.Mood, Float>>
  166:             DEFAULT_EMOTION_TO_MOOD = buildDefaultEmotionToMoodTable();
  167: 
  168:     private static volatile int cachedArcaneAmbientConfigGeneration = -1;
  169:     private static final ConcurrentMap<String, Optional<Field>> ARCANE_REFLECTION_FIELD_CACHE = new ConcurrentHashMap<>();
  170:     private static final ConcurrentMap<String, Optional<Method>> ARCANE_REFLECTION_METHOD_CACHE = new ConcurrentHashMap<>();
  171: 
  172:     private final PetComponent parent;
  173: 
  174:     private final EnumMap<PetComponent.Emotion, EmotionRecord> emotionRecords =
  175:             new EnumMap<>(PetComponent.Emotion.class);
  176:     private final EnumMap<PetComponent.Mood, Float> moodBlend =
  177:             new EnumMap<>(PetComponent.Mood.class);
  178:     private final EnumMap<PetComponent.Mood, Float> lastNormalizedWeights =
  179:             new EnumMap<>(PetComponent.Mood.class);
  180:     private final ArrayDeque<Float> dominantHistory = new ArrayDeque<>();
  181:     
  182:     // Emotional buildup tracking for momentum-based leveling
  183:     private final ArrayDeque<LevelSnapshot> levelHistory = new ArrayDeque<>();
  184:     private float recentLevel23Time = 0f;
  185:     private int previousMoodLevel = 0;
  186:     private float previousMoodStrength = 0f;
  187:     @Nullable
  188:     private PetComponent.Mood previousMoodSnapshot = null;
  189: 
  190:     private final EnumMap<PetComponent.Emotion, Float> paletteBlend =
  191:             new EnumMap<>(PetComponent.Emotion.class);
  192:     private List<PetComponent.WeightedEmotionColor> currentPaletteStops = Collections.emptyList();
  193:     private List<PetComponent.WeightedEmotionColor> stagedPaletteStops = Collections.emptyList();
  194:     private boolean hasPendingPalette = false;
  195:     private boolean paletteCommittedOnce = false;
  196:     private long lastPaletteCommitTime = 0L;
  197:     private int paletteGeneration = 0;
  198:     private int lastRenderedPaletteGeneration = -1;
  199:     private float animationIntensity = 0f;
  200:     private PetComponent.NatureEmotionProfile natureEmotionProfile = PetComponent.NatureEmotionProfile.EMPTY;
  201: 
  202:     private float lastRelationshipGuardObserved = RELATIONSHIP_BASE;
  203:     private float lastDangerWindowObserved = DANGER_BASE;
  204:     private float lastContagionCap = MathHelper.clamp(DEFAULT_IMPACT_CAP * 0.1f, 0.05f, 0.6f);
  205: 
  206:     private float[] scratchCadences = new float[16];
  207:     private int scratchCadenceCount = 0;
  208:     private float[] scratchIntensities = new float[16];
  209:     private int scratchIntensityCount = 0;
  210:     private float[] scratchSignals = new float[16];
  211:     private int scratchSignalCount = 0;
  212:     private float[] scratchFrequencies = new float[16];
  213:     private int scratchFrequencyCount = 0;
  214:     private float[] scratchBudgets = new float[16];
  215:     private int scratchBudgetCount = 0;
  216:     private final ArrayList<Candidate> scratchSurvivors = new ArrayList<>();
  217: 
  218:     private PetComponent.Mood currentMood = PetComponent.Mood.CALM;
  219:     private int moodLevel = 0;
  220:     private long lastMoodUpdate = 0L;
  221:     @SuppressWarnings("unused") // Reserved for future stimulus timing optimization
  222:     private long lastStimulusTime = 0L;
  223:     private boolean dirty = false;
  224:     
  225:     // Behavioral Momentum - tracks activity level for AI regulation
  226:     private float behavioralMomentum = 0.5f;           // 0=still, 1=hyperactive
  227:     private float momentumInertia = 0f;                // Smoothing factor for momentum changes
  228:     private long lastMomentumUpdate = 0L;
  229: 
  230:     // Multi-dimensional activity tracking for realistic behavior
  231:     private float physicalActivity = 0f;               // Running, jumping, playing
  232:     private float mentalActivity = 0f;                 // Puzzles, searching, tracking
  233:     private float socialActivity = 0f;                 // Interactions with owner/pets
  234:     private float restActivity = 0f;                   // Restorative downtime loops
  235:     private float recentPhysicalBurst = 0f;            // Fast-decaying exertion pulse for stamina response
  236: 
  237:     // Derived behavioral batteries layered above the raw activity feeds
  238:     private float socialCharge = 0.45f;                // 0=drained, 0.45=content introvert baseline, 1=pack euphoric
  239:     private float physicalStamina = 0.65f;             // Resets toward rested while physical exertion depletes it
  240:     private float mentalFocus = 0.6f;                  // High when mentally fresh, falls with cognitive strain
  241: 
  242:     private BehaviouralEnergyProfile cachedEnergyProfile = BehaviouralEnergyProfile.neutral();
  243:     private boolean energyProfileDirty = true;
  244: 
  245:     // Text animation caching
  246:     private Text cachedMoodText = null;
  247:     private Text cachedMoodTextWithDebug = null;
  248:     private long lastTextUpdateTime = -1L;
  249:     private int cachedLastLevel = -1;
  250: 
  251:     // Config cache
  252:     private int cachedConfigGeneration = -1;
  253:     private JsonObject cachedMoodsSection;
  254:     @SuppressWarnings("unused") // Reserved for future weighted mood calculations
  255:     private JsonObject cachedWeightSection;
  256:     private JsonObject cachedOpponentSection;
  257:     private JsonObject cachedAnimationSection;
  258:     private double cachedMomentum = 0.35d;
  259:     private double cachedSwitchMargin = 0.05d;
  260:     @SuppressWarnings("unused") // Reserved for future mood transition smoothing
  261:     private int cachedHysteresisTicks = 60;
  262:     private float cachedEpsilon = 0.05f;
  264:     private int cachedBaseAnimationUpdateInterval = 16;
  265:     
  266:     private final EnumMap<PetComponent.Mood, float[]> perMoodThresholds = new EnumMap<>(PetComponent.Mood.class);
  267:     private double cachedAnimationSpeedMultiplier = 0.15d;
  268:     private int cachedMinAnimationInterval = 4;
  269:     private int cachedMaxAnimationInterval = 40;
  270:     
  271:     private final Map<String, Float> cachedEmotionDecayMultipliers = new java.util.HashMap<>();
  272:     private final java.util.Set<String> cachedNegativeEmotions = new java.util.HashSet<>();
  273:     private final java.util.Set<String> cachedPositiveEmotions = new java.util.HashSet<>();
  274:     private final EnumMap<PetComponent.Emotion, Map<PetComponent.Mood, Float>> resolvedWeightCache =
  275:             new EnumMap<>(PetComponent.Emotion.class);
  276:     
  277:     private float cachedHabituationBase = HABITUATION_BASE;
  278:     private float cachedHalfLifeMultiplier = HALF_LIFE_MULTIPLIER;
  279:     private float cachedMinHalfLife = MIN_HALF_LIFE;
  280:     private float cachedMaxHalfLife = MAX_HALF_LIFE;
  281:     private float cachedNegativePersistence = 2.0f;
  282:     private float cachedConditionPresentMultiplier = 1.6f;
  283:     private float cachedHomeostasisRecoveryHalf = HOMEOSTASIS_RECOVERY_HALF;
  284:     private float cachedCadenceAlpha = CADENCE_ALPHA;
  285:     private float cachedVolatilityAlpha = VOLATILITY_ALPHA;
  286:     private float cachedPeakAlpha = PEAK_ALPHA;
  287:     private float cachedOpponentTransferMax = OPPONENT_TRANSFER_MAX;
  288:     private float cachedReboundGain = REBOUND_GAIN;
  289:     private float cachedRelationshipVariance = RELATIONSHIP_VARIANCE;
  290:     private float cachedCarePulseHalfLife = CARE_PULSE_HALF_LIFE;
  291:     private float cachedDangerHalfLife = DANGER_HALF_LIFE;
  292:     private double cachedPackSpiritRadius = 12.0d;
  293:     private int cachedPackSpiritMinPackmates = 1;
  294:     private long cachedPackSpiritGraceTicks = 140L;
  295:     private float cachedPackSpiritBondBonus = 0.3f;
  296:     private float cachedPackSpiritBaseContribution = 0.25f;
  297:     private float cachedPackSpiritClosenessWeight = 0.55f;
  298:     private float cachedPackSpiritCombatBonus = 0.25f;
  299:     private float cachedPackSpiritProtectiveWeight = 0.35f;
  300:     private float cachedPackSpiritFocusedWeight = 0.2f;
  301:     private float cachedPackSpiritPlayfulWeight = 0.1f;
  302:     private float cachedPackSpiritDiversityBonus = 0.15f;
  303:     private float cachedPackSpiritEngagementMax = 1.35f;
  304:     private final EnumMap<PetRoleType.RoleArchetype, Float> cachedPackSpiritRoleWeights =
  305:             new EnumMap<>(PetRoleType.RoleArchetype.class);
  306:     private int cachedOwnerDamageWindow = 160;
  307:     private long cachedOwnerDangerGraceTicks = 200L;
  308:     private long cachedOwnerLowHealthGraceTicks = 260L;
  309:     private float cachedOwnerLowHealthThreshold = 0.45f;
  310:     private float cachedOwnerCriticalHealthThreshold = 0.25f;
  311:     private long cachedOwnerStatusHazardGraceTicks = 180L;
  312:     private float cachedOwnerStatusHazardThreshold = 0.25f;
  313:     private long cachedArcaneOverflowLingerTicks = 220L;
  314:     private long cachedArcaneOverflowStreakGraceTicks = 200L;
  315:     private long cachedArcaneOverflowStatusGraceTicks = 160L;
  316:     private int cachedArcaneOverflowAmbientScanRadius = 4;
  317:     private float cachedArcaneOverflowMinimumEnergy = 0.25f;
  318:     private float cachedArcaneAmbientStructureBaseWeight = 0.35f;
  319:     private float cachedArcaneAmbientStructureMaxEnergy = 0.85f;
  320:     private float cachedArcaneAmbientDistanceExponent = 1.0f;
  321:     private float cachedArcaneAmbientMysticBonus = 0.2f;
  322:     private Map<Identifier, Float> cachedArcaneAmbientStructureWeights = new HashMap<>();
  323:     private float cachedArcaneRespawnAnchorEmptyMultiplier = 0.0f;
  324:     private float cachedArcaneRespawnAnchorChargeStep = 0.25f;
  325:     private float cachedArcaneRespawnAnchorMaxMultiplier = 1.0f;
  326:     private float cachedArcaneBeaconBaseMultiplier = 0.6f;
  327:     private float cachedArcaneBeaconPerLevelMultiplier = 0.25f;
  328:     private float cachedArcaneBeaconMaxMultiplier = 2.0f;
  329:     private long cachedArcaneCatalystRecentBloomTicks = 400L;
  330:     private float cachedArcaneCatalystActiveMultiplier = 1.0f;
  331:     private float cachedArcaneCatalystInactiveMultiplier = 0.25f;
  332:     private float cachedArcaneGearBaseWeight = 0.08f;
  333:     private float cachedArcaneGearLevelWeight = 0.06f;
  334:     private float cachedArcaneGearMaxContribution = 0.8f;
  335:     private float cachedArcaneGearOwnerMultiplier = 0.75f;
  336:     private float cachedArcaneGearPetMultiplier = 1.0f;
  337:     private float cachedArcaneStatusBaseWeight = 0.12f;
  338:     private float cachedArcaneStatusAmplifierWeight = 0.08f;
  339:     private float cachedArcaneStatusDurationWeight = 0.05f;
  340:     private float cachedArcaneStatusDurationCap = 3.0f;
  341:     private int cachedArcaneStatusDurationReference = 200;
  342:     private float cachedArcaneStatusMaxContribution = 0.6f;
  343:     private float cachedArcaneStatusOwnerMultiplier = 1.0f;
  344:     private float cachedArcaneStatusPetMultiplier = 1.15f;
  345:     private double cachedLonelyComfortRadius = 8.0d;
  346:     private double cachedLonelyComfortRadiusSquared = 64.0d;
  347:     private double cachedLonelyDistanceThreshold = 24.0d;
  348:     private double cachedLonelyDistanceThresholdSquared = 576.0d;
  349:     private long cachedLonelySaudadeGraceTicks = 400L;
  350:     private long cachedLonelyHiraethGraceTicks = 900L;
  351:     private long cachedLonelyOfflineGraceTicks = 200L;
  352:     private long cachedLonelyOfflineHiraethGraceTicks = 600L;
  353:     private long cachedLonelySocialGraceTicks = 260L;
  354:     private long cachedLonelyPackGraceTicks = 320L;
  355:     private float cachedLonelyPackStrengthThreshold = 0.2f;
  356:     private double cachedLonelyPackRadius = 16.0d;
  357:     private double cachedLonelyPackRadiusSquared = 256.0d;
  358:     private long cachedPositivePetGraceTicks = 200L;
  359:     private long cachedPositiveCrouchGraceTicks = 160L;
  360:     private long cachedPositiveSocialGraceTicks = 200L;
  361:     private long cachedPositivePlayGraceTicks = 240L;
  362:     private long cachedPositiveFeedGraceTicks = 260L;
  363:     private long cachedPositiveGiftGraceTicks = 360L;
  364:     private long cachedArcaneScanCooldownTicks = 80L;
  365:     private double cachedArcaneScanMovementThreshold = 3.0d;
  366:     private double cachedArcaneScanMovementThresholdSquared = 9.0d;
  367: 
  368:     private final EnumMap<PetComponent.Emotion, EnumSet<PetComponent.Emotion>> opponentPairs =
  369:             new EnumMap<>(PetComponent.Emotion.class);
  370: 
  372:         this.parent = parent;
  374:             moodBlend.put(mood, 0f);
  375:             lastNormalizedWeights.put(mood, 0f);
  377:         buildDefaultOpponentPairs();
  379: 
  381:         update();
  382:         return currentMood;
  384: 
  386:         update();
  387:         return moodLevel;
  389: 
  391:         long now = parent.getPet().getEntityWorld() instanceof ServerWorld sw ? sw.getTime() : lastMoodUpdate;
  392:         ensureFresh(now);
  394: 
  397:             updateEmotionStateAndMood(now);
  398:             dirty = false;
  401: 
  404:             return 1L;
  406:         long soonest = Long.MAX_VALUE;
  408:             float cadence = record.cadenceEMA > 0f ? record.cadenceEMA : cachedHabituationBase;
  409:             float adaptiveHalf = MathHelper.clamp(cadence * cachedHalfLifeMultiplier, cachedMinHalfLife, cachedMaxHalfLife);
  410:             long elapsed = Math.max(0L, now - record.lastUpdateTime);
  411:             long next = Math.max(1L, Math.round(adaptiveHalf - elapsed));
  413:                 soonest = next;
  417:             return 200L;
  419:         return Math.max(20L, soonest);
  421: 
  423:         update();
  424:         List<PetComponent.EmotionDebugInfo> debug = new ArrayList<>();
  427:                 debug.add(new PetComponent.EmotionDebugInfo(record.emotion, record.weight, false));
  430:         debug.sort(Comparator.comparingDouble((PetComponent.EmotionDebugInfo info) -> info.weight()).reversed());
  431:         return debug;
  433: 
  436:             return;
  438:         long now = eventTime > 0 ? eventTime : parent.getPet().getEntityWorld().getTime();
  439:         pushEmotion(delta.emotion(), delta.amount(), now);
  440:         lastStimulusTime = now;
  441:         dirty = true;
  443: 
  445:         dirty = true;
  447: 
  449:         natureEmotionProfile = profile != null ? profile : PetComponent.NatureEmotionProfile.EMPTY;
  450:         dirty = true;
  452: 
  454:         return new PetComponent.NatureGuardTelemetry(
  455:             lastRelationshipGuardObserved,
  456:             lastDangerWindowObserved,
  457:             lastContagionCap);
  459: 
  462:             emotionRecords.remove(emotion);
  463:             return;
  465: 
  466:         EmotionRecord record = emotionRecords.computeIfAbsent(emotion, e -> new EmotionRecord(e, now));
  467:         record.applyDecay(now, this);
  468: 
  470:             float reduction = Math.abs(amount);
  471:             record.intensity = Math.max(0f, record.intensity - reduction);
  472:             record.impactBudget = Math.max(0f, record.impactBudget - reduction * 0.5f);
  473:             record.lastEventTime = now;
  474:             record.lastUpdateTime = now;
  475:             return;
  477: 
  478:         // Global intensity cap at 0.5f to prevent overwhelming
  479:         float sample = MathHelper.clamp(amount, 0f, 0.5f);
  480:         sample *= getNatureStimulusBias(emotion);
  481:         sample = MathHelper.clamp(sample, 0f, 1f);
  482:         float volatilityMultiplier = parent.getNatureVolatilityMultiplier();
  483:         float resilienceMultiplier = parent.getNatureResilienceMultiplier();
  485:             record.startTime = now;
  487: 
  488:         long delta = record.lastEventTime > 0 ? Math.max(1L, now - record.lastEventTime) : Math.max(1L, Math.round(cachedHabituationBase));
  489:         record.lastEventTime = now;
  490:         record.lastUpdateTime = now;
  491: 
  493:             record.cadenceEMA = delta;
  495:             record.cadenceEMA = MathHelper.lerp(cachedCadenceAlpha, record.cadenceEMA, delta);
  497:         float volatilitySample = Math.abs(sample - record.intensity) * volatilityMultiplier;
  498:         volatilitySample = MathHelper.clamp(volatilitySample, 0f, 1f);
  499:         record.volatilityEMA = MathHelper.clamp(
  500:             MathHelper.lerp(cachedVolatilityAlpha, record.volatilityEMA, volatilitySample), 0f, 1f);
  501:         record.peakEMA = MathHelper.lerp(cachedPeakAlpha, record.peakEMA, Math.max(record.peakEMA, sample));
  502: 
  503:         // Rekindle boost: bring intensity toward new sample with spike bias
  504:         float spikeBias = MathHelper.clamp(0.25f + 0.35f * (float) Math.exp(-delta / Math.max(1f, record.cadenceEMA)), 0.25f, 0.60f);
  505:         // Validate spikeBias is in reasonable range
  506:         spikeBias = MathHelper.clamp(spikeBias, 0.0f, 1.0f);
  507:         record.intensity = MathHelper.clamp(MathHelper.lerp(spikeBias, record.intensity, sample), 0f, 1f);
  508: 
  509:         // Impact budget accrues using rekindle-aware boost
  510:         float rekindleBoost = 1.0f + Math.min(0.6f, record.sensitisationGain - 1.0f);
  511:         // Validate rekindleBoost is in reasonable range
  512:         rekindleBoost = MathHelper.clamp(rekindleBoost, 0.0f, 2.0f);
  513:         float impactGain = sample * rekindleBoost * resilienceMultiplier;
  514:         record.impactBudget = Math.min(getImpactCap(), record.impactBudget + impactGain);
  515: 
  516:         // Habituation & Sensitization (psychologically accurate):
  517:         // - Frequent stimuli (fast cadence) → habituation → LOWER gain (desensitized)
  518:         // - Rare stimuli (slow cadence) → sensitization → HIGHER gain (re-sensitized)
  519:         // - Normal cadence → drift back to baseline (1.0)
  520:         float cadenceRatio = record.cadenceEMA > 0f ? MathHelper.clamp(delta / record.cadenceEMA, 0f, 2.5f) : 1f;
  521:         float sensitisationDelta;
  523:             // Stimuli arriving FASTER than expected (short gaps) → habituation
  524:             // Reduce gain: pet becomes desensitized to repeated stimuli
  525:             sensitisationDelta = -0.35f * (0.8f - cadenceRatio); // Phase 2 tuning
  527:             // Stimuli arriving SLOWER than expected (long gaps) → sensitization
  528:             // Increase gain: pet becomes re-sensitized after break
  529:             sensitisationDelta = 0.15f * Math.min(1f, cadenceRatio - 1.5f); // Phase 2 tuning
  531:             // Normal cadence → gentle drift toward baseline (1.0)
  532:             sensitisationDelta = (1.0f - record.sensitisationGain) * 0.05f;
  534:         // Apply resilience modifier: resilient pets habituate slower/sensitize faster
  535:         sensitisationDelta *= resilienceMultiplier;
  536:         record.sensitisationGain = MathHelper.clamp(record.sensitisationGain + sensitisationDelta, 0.5f, 1.4f);
  537: 
  539:             record.habituationSlope = Math.max(cachedHabituationBase, record.cadenceEMA * 1.1f);
  541:             float targetSlope = Math.max(cachedHabituationBase * 0.5f, record.cadenceEMA * 1.2f);
  542:             record.habituationSlope = MathHelper.lerp(0.1f, record.habituationSlope, targetSlope);
  544: 
  545:         // Homeostasis bias trends back toward baseline when intensity decreases
  546:         float towardBaseline = record.intensity < record.homeostasisBias ? 0.12f : -0.06f;
  547:         float tunedTowardBaseline = towardBaseline * resilienceMultiplier
  548:                 * getNatureQuirkReboundModifier(emotion);
  549:         record.homeostasisBias = MathHelper.clamp(record.homeostasisBias + tunedTowardBaseline, 0.75f, 1.35f);
  550: 
  551:         refreshContextGuards(record, now, delta);
  553: 
  555:         long now = parent.getPet().getEntityWorld().getTime();
  556:         float bondFactor = parent.computeBondResilience(now);
  557:         addContagionShare(emotion, amount, now, bondFactor);
  559: 
  562:             return;
  564:         EmotionRecord record = emotionRecords.computeIfAbsent(emotion, e -> new EmotionRecord(e, now));
  565:         record.applyDecay(now, this);
  566: 
  567:         float spreadBias = getNatureContagionSpreadBias(emotion);
  568:         // Validate spreadBias is in reasonable range
  569:         spreadBias = MathHelper.clamp(spreadBias, 0.0f, 2.0f);
  570:         float tunedAmount = amount * spreadBias;
  571:         // Validate bondFactor is in reasonable range
  572:         bondFactor = MathHelper.clamp(bondFactor, 0.0f, 2.0f);
  573:         float cap = computeContagionCap(bondFactor);
  574:         float tunedCap = cap * MathHelper.clamp(spreadBias, 0.7f, 1.35f);
  575:         float minCap = Math.min(cap, 0.05f);
  576:         float maxCap = Math.max(cap, 0.6f);
  577:         tunedCap = MathHelper.clamp(tunedCap, minCap, maxCap);
  578:         lastContagionCap = tunedCap;
  579:         float updated = MathHelper.clamp(record.contagionShare + tunedAmount, -tunedCap, tunedCap);
  580:         record.contagionShare = updated;
  581:         record.lastUpdateTime = now;
  583: 
  585:         update();
  586:         return MathHelper.clamp(moodBlend.getOrDefault(mood, 0f), 0f, 1f);
  588: 
  590:         update();
  591:         return Collections.unmodifiableMap(new EnumMap<>(moodBlend));
  593: 
  595:         update();
  596:         EnumMap<PetComponent.Emotion, Float> active = new EnumMap<>(PetComponent.Emotion.class);
  599:                 active.put(record.emotion, MathHelper.clamp(record.weight, 0f, 1f));
  602:         return Collections.unmodifiableMap(active);
  604: 
  606:         return getMoodStrength(mood) >= threshold;
  608: 
  610:         update();
  611:         return currentMood;
  613: 
  614:     @Nullable
  616:         update();
  617:         return emotionRecords.values().stream()
  618:                 .max(Comparator.comparingDouble(r -> r.weight))
  619:                 .map(record -> record.emotion)
  620:                 .orElse(null);
  622: 
  624:         PetComponent.Emotion dominant = getDominantEmotion();
  625:         return dominant != null ? prettify(dominant.name()) : "None";
  627: 
  629:         return getCachedMoodText(false);
  631: 
  633:         return getCachedMoodText(true);
  635: 
  637:         update();
  638:         return currentPaletteStops;
  640: 
  642:         update();
  643:         return animationIntensity;
  645:     
  646:     /**
  647:      * Records behavioral activity from AI goals or interactions.
  648:      * Accumulates until next momentum update.
  649:      * 
  650:      * @param intensity Activity intensity (0-1, where 1 is max exertion)
  651:      * @param durationTicks How long the activity lasted
  652:      */
  654:         recordBehavioralActivity(intensity, durationTicks, ActivityType.PHYSICAL);
  656:     
  657:     /**
  658:      * Records typed behavioral activity for nuanced momentum tracking.
  659:      * Different activity types contribute differently to overall momentum.
  660:      */
  662:         if (intensity < EPSILON || durationTicks <= 0) return;
  663:         
  664:         float normalizedIntensity = MathHelper.clamp(intensity, 0f, 1f);
  665:         float contribution = normalizedIntensity * durationTicks / 100f;
  666:         
  667:         // Apply activity with caps to prevent overflow from rapid recording
  670:                 physicalActivity = Math.min(5f, physicalActivity + contribution * 1.2f);
  671:                 recentPhysicalBurst = Math.min(1f, recentPhysicalBurst + contribution * 2.5f);
  673:             case MENTAL -> mentalActivity = Math.min(5f, mentalActivity + contribution * 0.8f);
  674:             case SOCIAL -> socialActivity = Math.min(5f, socialActivity + contribution * 0.9f);
  675:             case REST -> restActivity = Math.min(5f, restActivity + contribution);
  677:         energyProfileDirty = true;
  678:         dirty = true;
  680:     
  681:     /**
  682:      * Activity types for behavioral momentum tracking.
  683:      */
  685:         PHYSICAL,  // Movement, play, exercise
  686:         MENTAL,    // Problem-solving, searching, tracking
  687:         SOCIAL,    // Interactions with owner or other pets
  688:         REST       // Calming, restorative loops and naps
  690:     
  691:     /**
  692:      * Gets current behavioral momentum level.
  693:      * 0.0 = completely still/tired, 0.5 = neutral, 1.0 = hyperactive
  694:      */
  696:         update();
  697:         return behavioralMomentum;
  699: 
  700:     /**
  701:      * Snapshot of the layered behavioural energy stack.
  702:      */
  703:     @Deprecated(forRemoval = false)
  705:         return getBehaviouralEnergyProfile();
  707: 
  708:     /**
  709:      * Snapshot of the layered behavioural energy stack.
  710:      */
  712:         update();
  714:             refreshEnergyProfile();
  716:         return cachedEnergyProfile;
  718: 
  719:     /**
  720:      * Gets momentum-based movement speed multiplier for AI/animation.
  721:      * Returns 0.7-1.3 range for natural speed variation.
  722:      */
  724:         update();
  725:         // Map 0.0-1.0 momentum to 0.7-1.3 speed multiplier
  726:         // Low momentum = slower movement, high momentum = faster movement
  727:         return 0.7f + (behavioralMomentum * 0.6f);
  729:     
  730:     /**
  731:      * Gets momentum-based animation speed multiplier.
  732:      * Returns 0.8-1.4 range for visible but not jarring animation changes.
  733:      */
  735:         update();
  736:         // Tired pets animate slower, energetic pets faster
  737:         // Slightly more dramatic range than movement for visual feedback
  738:         return 0.8f + (behavioralMomentum * 0.6f);
  740:     
  741:     /**
  742:      * Debug info for momentum state inspection.
  743:      */
  745:         return String.format(
  746:             "Momentum: %.2f | P:%.2f M:%.2f S:%.2f | Stamina:%.2f Focus:%.2f SocialCharge:%.2f | Inertia:%.3f",
  747:             behavioralMomentum,
  748:             physicalActivity,
  749:             mentalActivity,
  750:             socialActivity,
  751:             physicalStamina,
  752:             mentalFocus,
  753:             socialCharge,
  754:             momentumInertia);
  756: 
  758:         NbtCompound emotions = new NbtCompound();
  760:             NbtCompound tag = new NbtCompound();
  761:             tag.putFloat("intensity", record.intensity);
  762:             tag.putFloat("impact", record.impactBudget);
  763:             tag.putFloat("cadence", record.cadenceEMA);
  764:             tag.putFloat("volatility", record.volatilityEMA);
  765:             tag.putFloat("peak", record.peakEMA);
  766:             tag.putFloat("habituation", record.habituationSlope);
  767:             tag.putFloat("sensitisation", record.sensitisationGain);
  768:             tag.putFloat("homeostasis", record.homeostasisBias);
  769:             tag.putFloat("contagion", record.contagionShare);
  770:             tag.putFloat("relationship", record.relationshipGuard);
  771:             tag.putFloat("danger", record.dangerWindow);
  772:             tag.putFloat("appraisal", record.appraisalConfidence);
  773:             tag.putFloat("weight", record.weight);
  774:             tag.putLong("start", record.startTime);
  775:             tag.putLong("lastEvent", record.lastEventTime);
  776:             tag.putLong("lastUpdate", record.lastUpdateTime);
  777:             emotions.put(record.emotion.name(), tag);
  779:         nbt.put("emotionRecords", emotions);
  780: 
  781:         NbtCompound blend = new NbtCompound();
  783:             blend.putFloat(entry.getKey().name(), entry.getValue());
  785:         nbt.put("moodBlend", blend);
  786:         nbt.putString("currentMood", currentMood.name());
  787:         nbt.putInt("moodLevel", moodLevel);
  788: 
  789:         NbtCompound history = new NbtCompound();
  790:         int idx = 0;
  792:             history.putFloat(Integer.toString(idx++), value);
  794:         nbt.put("dominantHistory", history);
  795:         
  796:         // Behavioral energy stack persists momentum and derived batteries
  797:         nbt.putFloat("behavioralMomentum", behavioralMomentum);
  798:         nbt.putFloat("socialCharge", socialCharge);
  799:         nbt.putFloat("physicalStamina", physicalStamina);
  800:         nbt.putFloat("mentalFocus", mentalFocus);
  802: 
  804:         emotionRecords.clear();
  808:                     PetComponent.Emotion emotion;
  810:                         emotion = PetComponent.Emotion.valueOf(key);
  812:                         continue;
  815:                         EmotionRecord record = new EmotionRecord(emotion, parent.getPet().getEntityWorld().getTime());
  816:                         record.intensity = tag.getFloat("intensity").orElse(0f);
  817:                         record.impactBudget = tag.getFloat("impact").orElse(0f);
  818:                         record.cadenceEMA = tag.getFloat("cadence").orElse(0f);
  819:                         record.volatilityEMA = tag.getFloat("volatility").orElse(0f);
  820:                         record.peakEMA = tag.getFloat("peak").orElse(0f);
  821:                         record.habituationSlope = tag.getFloat("habituation").orElse(cachedHabituationBase);
  822:                         record.sensitisationGain = tag.getFloat("sensitisation").orElse(1.0f);
  823:                         record.homeostasisBias = tag.getFloat("homeostasis").orElse(1.0f);
  824:                         record.contagionShare = tag.getFloat("contagion").orElse(0f);
  825:                         record.relationshipGuard = tag.getFloat("relationship").orElse(RELATIONSHIP_BASE);
  826:                         record.dangerWindow = tag.getFloat("danger").orElse(DANGER_BASE);
  827:                         record.appraisalConfidence = tag.getFloat("appraisal").orElse(APPRAISAL_BASE);
  828:                         record.weight = tag.getFloat("weight").orElse(0f);
  829:                         record.startTime = tag.getLong("start").orElse(parent.getPet().getEntityWorld().getTime());
  830:                         record.lastEventTime = tag.getLong("lastEvent").orElse(record.startTime);
  831:                         record.lastUpdateTime = tag.getLong("lastUpdate").orElse(record.lastEventTime);
  832:                         emotionRecords.put(emotion, record);
  837: 
  838:         moodBlend.clear();
  840:             moodBlend.put(mood, 0f);
  844:                 float sum = 0f;
  847:                         PetComponent.Mood mood = PetComponent.Mood.valueOf(key);
  848:                         float value = blend.getFloat(key).orElse(0f);
  850:                             moodBlend.put(mood, value);
  851:                             sum += value;
  858:                         entry.setValue(entry.getValue() / sum);
  865:                 currentMood = PetComponent.Mood.valueOf(value);
  867:                 currentMood = PetComponent.Mood.CALM;
  870:         nbt.getInt("moodLevel").ifPresent(value -> moodLevel = value);
  871: 
  872:         lastNormalizedWeights.clear();
  873:         lastNormalizedWeights.putAll(moodBlend);
  874: 
  875:         dominantHistory.clear();
  878:                 List<String> keys = new ArrayList<>(history.getKeys());
  879:                 keys.sort(Comparator.naturalOrder());
  881:                     history.getFloat(key).ifPresent(value -> dominantHistory.add(value));
  885:         paletteBlend.clear();
  886:         currentPaletteStops = Collections.emptyList();
  887:         stagedPaletteStops = Collections.emptyList();
  888:         hasPendingPalette = false;
  889:         paletteCommittedOnce = false;
  890:         lastPaletteCommitTime = 0L;
  891:         paletteGeneration++;
  892:         
  893:         // Behavioral energy stack - restore momentum plus batteries, activities rebuild naturally
  894:         behavioralMomentum = nbt.getFloat("behavioralMomentum").orElse(0.5f);
  895:         socialCharge = MathHelper.clamp(nbt.getFloat("socialCharge").orElse(0.45f), 0.1f, 1f);
  896:         physicalStamina = MathHelper.clamp(nbt.getFloat("physicalStamina").orElse(0.65f), 0.05f, 1f);
  897:         mentalFocus = MathHelper.clamp(nbt.getFloat("mentalFocus").orElse(0.6f), 0.05f, 1f);
  898:         // Activities intentionally not persisted - they should start fresh on load
  899:         physicalActivity = 0f;
  900:         mentalActivity = 0f;
  901:         socialActivity = 0f;
  902:         restActivity = 0f;
  903:         recentPhysicalBurst = 0f;
  904:         lastMomentumUpdate = 0L;
  905:         energyProfileDirty = true;
  907: 
  908:     // --------------------------------------------------------------------------------------------
  909:     // Core interpretation pipeline
  910:     // --------------------------------------------------------------------------------------------
  911: 
  914:             return;
  916:         lastMoodUpdate = now;
  917: 
  918:         ensureConfigCache();
  919:         float epsilon = Math.max(EPSILON, cachedEpsilon);
  920:         float guardModifier = MathHelper.clamp(parent.getNatureGuardModifier(), 0.1f, 3.0f);
  921:         float contagionModifier = MathHelper.clamp(parent.getNatureContagionModifier(), 0.1f, 3.0f);
  922:         lastRelationshipGuardObserved = MathHelper.clamp(RELATIONSHIP_BASE * guardModifier, 0.6f, 1.6f);
  923:         lastDangerWindowObserved = MathHelper.clamp(DANGER_BASE * guardModifier, 0.6f, 1.7f);
  924:         float baseCap = DEFAULT_IMPACT_CAP * 0.1f * contagionModifier;
  925:         float minCap = 0.05f * Math.min(1f, contagionModifier);
  926:         float maxCap = 0.6f * Math.max(1f, contagionModifier);
  927:         lastContagionCap = MathHelper.clamp(baseCap, minCap, maxCap);
  928: 
  929:         // Update behavioral momentum
  930:         updateBehavioralMomentum(now);
  931:         
  932:         // Decay + cleanup pass
  933:         List<EmotionRecord> active = collectActiveRecords(now, epsilon);
  934: 
  936:             resetToCalmBaseline();
  937:             return;
  939: 
  940:         int activeSize = active.size();
  941: 
  942:         scratchCadences = ensureCapacity(scratchCadences, activeSize);
  943:         scratchCadenceCount = activeSize;
  945:             EmotionRecord record = active.get(i);
  946:             scratchCadences[i] = record.cadenceEMA > 0f ? record.cadenceEMA : HABITUATION_BASE;
  948:         float cadenceMedian = selectQuantile(scratchCadences, scratchCadenceCount, 0.5f, HABITUATION_BASE);
  949: 
  950:         scratchIntensities = ensureCapacity(scratchIntensities, activeSize);
  951:         scratchIntensityCount = activeSize;
  953:             scratchIntensities[i] = active.get(i).intensity;
  955:         // Quantile analysis for mood calibration (reserved for advanced mood detection)
  956:         // float quietFloor = selectQuantile(scratchIntensities, scratchIntensityCount, 0.2f, 0.12f);
  957:         // float quietCeil = selectQuantile(scratchIntensities, scratchIntensityCount, 0.65f, 0.6f);
  958: 
  959:         ArrayList<Candidate> candidates = new ArrayList<>(activeSize);
  960:         scratchSignals = ensureCapacity(scratchSignals, activeSize);
  961:         scratchSignalCount = activeSize;
  963:             EmotionRecord record = active.get(i);
  964:             float freshness = computeFreshness(record, now);
  965:             float freq = record.cadenceEMA > 0f ? MathHelper.clamp(cadenceMedian / record.cadenceEMA, 0f, 3.5f) : 0f;
  966:             // Validate frequency is in reasonable range
  967:             freq = MathHelper.clamp(freq, 0.0f, 5.0f);
  968:             float signal = (record.intensity * (0.35f + 0.65f * freshness))
  969:                     + (0.3f * (float) Math.sqrt(Math.max(0f, freq * record.impactBudget)));
  970:             scratchSignals[i] = signal;
  971:             candidates.add(new Candidate(record, freshness, freq, signal));
  973: 
  974:         float medianSignal = selectQuantile(scratchSignals, scratchSignalCount, 0.5f, 0f);
  975:         float threshold = medianSignal * 0.6f;
  976:         ArrayList<Candidate> survivors = scratchSurvivors;
  977:         survivors.clear();
  980:                 survivors.add(candidate);
  984:             Candidate best = Collections.max(candidates, Comparator.comparingDouble(c -> c.signal));
  985:             survivors.add(best);
  987: 
  988:         // Derived stats for weighting
  989:         scratchFrequencies = ensureCapacity(scratchFrequencies, survivors.size());
  990:         scratchFrequencyCount = survivors.size();
  992:             scratchFrequencies[i] = survivors.get(i).frequency;
  994:         float freqMedian = selectQuantile(scratchFrequencies, scratchFrequencyCount, 0.5f, 1f);
  995:         // Reserved for future frequency-based mood adjustments
  996:         @SuppressWarnings("unused")
  997:         float unused = freqMedian;
  998:         // Frequency and recency analysis reserved for future temporal patterns
  999:         float impactCap = computeImpactCap(active);
 1000:         float weightCap = Math.max(impactCap * 1.5f, DEFAULT_WEIGHT_CAP);
 1001: 
 1002:         // Weight synthesis - Simplified additive model based on psychological realism
 1003:         List<Candidate> weighted = new ArrayList<>();
 1005:             EmotionRecord record = candidate.record;
 1006:             float intensity = MathHelper.clamp(record.intensity, 0f, 1f);
 1007:             // Double-check intensity bounds
 1008:             intensity = MathHelper.clamp(intensity, 0.0f, 1.0f);
 1009: 
 1010:             // Base weight: intensity scaled by accumulated impact
 1011:             float baseWeight = intensity * (1.0f + MathHelper.clamp(record.impactBudget / impactCap, 0f, 1.5f));
 1012: 
 1013:             // Recency boost: Fresh emotions get a spike, then decay naturally
 1014:             // Nature-modified: aligned emotions spike harder, misaligned spike less
 1015:             float lastAge = Math.max(0f, (float) (now - record.lastEventTime));
 1016:             float recencyBoost = 0f;
 1018:                 // Strong boost for very fresh emotions (< 3 seconds)
 1019:                 float baseBoost = 0.4f * (1.0f - lastAge / 60f);
 1020:                 float natureRecencyMod = getNatureRecencyBoostModifier(record.emotion);
 1021:                 recencyBoost = baseBoost * natureRecencyMod;
 1023:             // Validate recencyBoost is in reasonable range
 1024:             recencyBoost = MathHelper.clamp(recencyBoost, 0.0f, 1.0f);
 1025: 
 1026:             // Persistence bonus: Ongoing conditions maintain weight
 1027:             // Nature-modified: aligned emotions persist longer
 1028:             float persistenceBonus = 0f;
 1030:                 // Condition still present, add sustained weight
 1031:                 float basePersistence = 0.3f * intensity;
 1032:                 float naturePersistenceMod = getNaturePersistenceModifier(record.emotion);
 1033:                 persistenceBonus = basePersistence * naturePersistenceMod;
 1035:             // Validate persistenceBonus is in reasonable range
 1036:             persistenceBonus = MathHelper.clamp(persistenceBonus, 0.0f, 1.5f);
 1037: 
 1038:             // Habituation penalty: Reduce weight if stimuli are too frequent
 1039:             float habituationPenalty = 0f;
 1041:                 // Very frequent stimuli (< 4 seconds) cause habituation
 1042:                 habituationPenalty = -0.35f * (1.0f - record.cadenceEMA / 80f); // Phase 2 tuning
 1044:             // Validate habituationPenalty is in reasonable range
 1045:             habituationPenalty = MathHelper.clamp(habituationPenalty, -1.0f, 0.0f);
 1046: 
 1047:             // Context modulation: Emotion-specific boosts/penalties based on bond, danger, etc.
 1048:             refreshContextGuards(record, now, Math.max(1L, now - record.lastUpdateTime));
 1049:             float contextModulation = computeEmotionSpecificContextModulation(record, now);
 1050:             // Validate contextModulation is in reasonable range
 1051:             contextModulation = MathHelper.clamp(contextModulation, -1.0f, 1.0f);
 1052: 
 1053:             // Nature profile weighting
 1054:             float profileWeightBias = getNatureWeightBias(record.emotion);
 1055:             // Validate profileWeightBias is in reasonable range
 1056:             profileWeightBias = MathHelper.clamp(profileWeightBias, 0.0f, 2.0f);
 1057: 
 1058:             // Additive formula: sum components, then scale by profile
 1059:             float rawWeight = (baseWeight + recencyBoost + persistenceBonus + habituationPenalty + contextModulation + record.contagionShare) * profileWeightBias;
 1060:             rawWeight = MathHelper.clamp(rawWeight, 0f, weightCap);
 1061: 
 1062:             record.weight = rawWeight;
 1063:             weighted.add(new Candidate(record, candidate.freshness, candidate.frequency, rawWeight));
 1065: 
 1067:             resetToCalmBaseline();
 1068:             return;
 1070: 
 1071:         // Opponent transfer
 1072:         applyOpponentTransfers(weighted, weightCap);
 1073: 
 1074:         // Sync the record weights with any transfer-adjusted signals so downstream
 1075:         // consumers (dominant mood queries, persistence, debugging) reflect the
 1076:         // post-transfer values.
 1078:             candidate.record.weight = candidate.signal;
 1080: 
 1081:         // Build mood vector
 1082:         EnumMap<PetComponent.Mood, Float> targetBlend = new EnumMap<>(PetComponent.Mood.class);
 1084:             targetBlend.put(mood, 0f);
 1087:             Map<PetComponent.Mood, Float> mapping = getEmotionToMoodWeights(candidate.record.emotion);
 1089:                 float contribution = candidate.signal * entry.getValue();
 1090:                 targetBlend.merge(entry.getKey(), Math.max(0f, contribution), Float::sum);
 1093: 
 1094:         float total = 0f;
 1096:             total += Math.max(0f, value);
 1099:             resetToCalmBaseline();
 1100:             return;
 1103:             entry.setValue(Math.max(0f, entry.getValue()) / total);
 1105: 
 1106:         lastNormalizedWeights.clear();
 1107:         lastNormalizedWeights.putAll(targetBlend);
 1108: 
 1109:         // Dual-timescale blending: fast for fresh spikes, slow for persistent drifts
 1110:         // Strong recent emotions should switch quickly, weak persistent ones should drift slowly
 1111:         float maxEmotionFreshness = 0f;
 1112:         float maxEmotionWeight = 0f;
 1114:             maxEmotionFreshness = Math.max(maxEmotionFreshness, c.freshness);
 1115:             maxEmotionWeight = Math.max(maxEmotionWeight, c.signal);
 1117:         
 1118:         // Adaptive momentum system: balances responsiveness vs stability
 1119:         // - Fresh strong spikes: low momentum (fast switch, responsive)
 1120:         // - Persistent weak emotions: high momentum (slow drift, stable)
 1121:         // - Smooth interpolation between states prevents oscillation
 1122:         float baseMomentum = (float) MathHelper.clamp(cachedMomentum, 0.0, 1.0) * 0.85f; // Phase 2 tuning
 1123:         
 1124:         // Calculate freshness and weight factors (0-1 normalized)
 1125:         float freshnessFactor = MathHelper.clamp(maxEmotionFreshness, 0f, 1f);
 1126:         float weightFactor = MathHelper.clamp(maxEmotionWeight / 4.0f, 0f, 1f); // Normalize assuming max ~4
 1127:         
 1128:         // Combine factors: high fresh+weight = low momentum (fast), low = high momentum (slow)
 1129:         float combined = (freshnessFactor + weightFactor) / 2f;
 1130:         float adaptiveMomentum = baseMomentum * (1.35f - combined * 0.9f); // Phase 2 tuning
 1131:         
 1132:         // Clamp to safe range: fast enough to feel responsive, slow enough to avoid jitter
 1133:         adaptiveMomentum = MathHelper.clamp(adaptiveMomentum, 0.15f, 0.85f);
 1134:         
 1136:             float cur = moodBlend.getOrDefault(mood, 0f);
 1137:             float tar = targetBlend.getOrDefault(mood, 0f);
 1138:             float blended = cur + (tar - cur) * adaptiveMomentum;
 1139:             moodBlend.put(mood, MathHelper.clamp(blended, 0f, 1f));
 1141: 
 1142:         // Apply behavioral momentum influence before normalization
 1143:         applyBehavioralMomentumInfluence();
 1144:         
 1145:         normalizeBlend(moodBlend);
 1146: 
 1147:         updateEmotionPalette(weighted);
 1148:         updateAnimationIntensity(weighted);
 1149: 
 1150:         PetComponent.Mood previousMood = currentMood;
 1151:         float previousStrength = moodBlend.getOrDefault(previousMood, 0f);
 1152:         PetComponent.Mood bestMood = moodBlend.entrySet().stream()
 1153:                 .max(Map.Entry.comparingByValue())
 1154:                 .map(Map.Entry::getKey)
 1155:                 .orElse(PetComponent.Mood.CALM);
 1156:         float bestStrength = moodBlend.getOrDefault(bestMood, 0f);
 1157: 
 1158:         float momentumBand = Math.max((float) cachedSwitchMargin, computeMomentumBand(previousStrength));
 1160:             currentMood = previousMood;
 1162:             currentMood = bestMood;
 1164: 
 1165:         float currentStrength = moodBlend.getOrDefault(currentMood, 0f);
 1166:         updateDominantHistory(currentStrength);
 1167:         updateMoodLevel(currentStrength);
 1168:         parent.notifyMoodBlendUpdated();
 1169:         parent.notifyEmotionSampleUpdated();
 1171: 
 1173:         List<EmotionRecord> active = new ArrayList<>();
 1175:             record.applyDecay(now, this);
 1176:             float contagionMagnitude = Math.abs(record.contagionShare);
 1177:             if (record.intensity <= epsilon && record.impactBudget <= epsilon
 1179:                 emotionRecords.remove(record.emotion);
 1180:                 continue;
 1182:             active.add(record);
 1184:         return active;
 1186: 
 1189:             moodBlend.put(mood, 0f);
 1191:         moodBlend.put(PetComponent.Mood.CALM, 1f);
 1192:         currentMood = PetComponent.Mood.CALM;
 1193:         moodLevel = 0;
 1194:         previousMoodSnapshot = currentMood;
 1195:         updateDominantHistory(0f);
 1196:         lastNormalizedWeights.clear();
 1198:             lastNormalizedWeights.put(mood, moodBlend.getOrDefault(mood, 0f));
 1201:             paletteBlend.clear();
 1202:             currentPaletteStops = Collections.emptyList();
 1203:             paletteGeneration++;
 1206: 
 1208:         // Get mood-specific thresholds if available, otherwise use default
 1209:         PetComponent.Mood moodEvaluated = currentMood;
 1210:         float[] thresholds = getMoodSpecificThresholds(moodEvaluated);
 1211: 
 1212:         int lastLevel = moodLevel;
 1213: 
 1214:         // Apply buildup multiplier based on emotional momentum
 1215:         float buildupMultiplier = computeBuildupMultiplier(moodEvaluated, currentStrength);
 1216:         float effectiveStrength = MathHelper.clamp(currentStrength * buildupMultiplier, 0f, 1f);
 1217: 
 1218:         // Calculate raw level from thresholds (simple linear scan - O(n) where n=3, very cheap)
 1219:         int rawLevel = 0;
 1222:                 rawLevel++;
 1224:                 break;  // Thresholds are sorted, can early exit
 1227: 
 1228:         // Apply hysteresis to prevent level jitter
 1229:         int newLevel = applyLevelHysteresis(rawLevel, effectiveStrength, thresholds, lastLevel);
 1230: 
 1231:         int clampedLevel = MathHelper.clamp(newLevel, 0, thresholds.length);
 1232:         // Update level history for habituation tracking (only if level actually changed)
 1234:             updateLevelHistory(clampedLevel, lastMoodUpdate);
 1236: 
 1237:         moodLevel = clampedLevel;
 1238:         previousMoodLevel = clampedLevel;
 1239:         previousMoodStrength = currentStrength;
 1240:         previousMoodSnapshot = moodEvaluated;
 1242: 
 1245:             dominantHistory.removeFirst();
 1247:         dominantHistory.add(MathHelper.clamp(strength, 0f, 1f));
 1249: 
 1250:     /**
 1251:      * Updates behavioral momentum based on accumulated activity and natural decay.
 1252:      */
 1254:         long delta = now - lastMomentumUpdate;
 1255:         if (delta < 20) return; // Update every second
 1256:         
 1257:         lastMomentumUpdate = now;
 1258: 
 1259:         // Calculate personality-influenced baseline from mood and nature
 1260:         float baseline = calculateMomentumBaseline();
 1261: 
 1262:         // Calculate target momentum from activities while keeping idle at baseline
 1263:         float activityLevel = MathHelper.clamp(calculateActivityLevel(), 0f, 1f);
 1264:         float activityBoost = activityLevel * 0.4f;
 1265:         float restCalm = MathHelper.clamp(restActivity * 0.3f, 0f, 0.35f);
 1266:         float targetMomentum = MathHelper.clamp(baseline + activityBoost - restCalm, 0f, 1f);
 1267: 
 1268:         // Apply inertia for smooth transitions
 1269:         float momentumGap = Math.abs(targetMomentum - behavioralMomentum);
 1270:         float inertiaFactor = calculateInertiaFactor(delta, momentumGap);
 1271:         float momentumDelta = (targetMomentum - behavioralMomentum) * inertiaFactor;
 1272: 
 1273:         // Update momentum with smoothing
 1274:         behavioralMomentum += momentumDelta;
 1275:         momentumInertia = MathHelper.lerp(0.1f, momentumInertia, Math.abs(momentumDelta));
 1276: 
 1277:         // Add organic variation for lifelike behavior
 1278:         behavioralMomentum += generateOrganicVariation(now);
 1279: 
 1280:         behavioralMomentum = MathHelper.clamp(behavioralMomentum, 0f, 1f);
 1281: 
 1282:         updateEnergyBatteries(now, delta);
 1283: 
 1284:         // Decay activity accumulators after they've fed the batteries
 1285:         decayActivities(delta);
 1286:         energyProfileDirty = true;
 1287:         refreshEnergyProfile();
 1289:     
 1290:     /**
 1291:      * Calculates personality-influenced momentum baseline.
 1292:      */
 1294:         float baseline = 0.5f;
 1295:         
 1296:         // Mood influences
 1297:         baseline += moodBlend.getOrDefault(PetComponent.Mood.PLAYFUL, 0f) * 0.2f;
 1298:         baseline += moodBlend.getOrDefault(PetComponent.Mood.RESTLESS, 0f) * 0.25f;
 1299:         baseline += moodBlend.getOrDefault(PetComponent.Mood.CURIOUS, 0f) * 0.15f;
 1300:         baseline -= moodBlend.getOrDefault(PetComponent.Mood.CALM, 0f) * 0.3f;
 1301:         baseline -= moodBlend.getOrDefault(PetComponent.Mood.SAUDADE, 0f) * 0.2f;
 1302:         
 1303:         // Age influences
 1305:             baseline += 0.2f; // Young pets are more energetic
 1307:         
 1308:         // Nature influences (volatile pets have higher baseline)
 1309:         float volatility = parent.getNatureVolatilityMultiplier();
 1310:         baseline += (volatility - 1.0f) * 0.15f;
 1311:         
 1312:         // Time of day influence (subtle circadian rhythm)
 1313:         long timeOfDay = parent.getPet().getEntityWorld().getTimeOfDay() % 24000;
 1315:             baseline += 0.05f; // Slightly more active during day
 1317:             baseline -= 0.05f; // Slightly less active at night
 1319:         
 1320:         // Health influence - injured pets have less energy
 1321:         float healthRatio = parent.getPet().getHealth() / parent.getPet().getMaxHealth();
 1323:             float healthPenalty = (0.5f - healthRatio) * 0.4f; // Up to -0.2 at critical health
 1324:             baseline -= healthPenalty;
 1326:         
 1327:         return MathHelper.clamp(baseline, 0.15f, 0.85f);
 1329:     
 1330:     /**
 1331:      * Calculates current activity level from multi-dimensional tracking.
 1332:      */
 1334:         // Weighted combination of activity types
 1335:         float physical = Math.min(1f, physicalActivity * 0.4f);
 1336:         float mental = Math.min(1f, mentalActivity * 0.3f);
 1337:         float social = Math.min(1f, socialActivity * 0.3f);
 1338: 
 1339:         // Combined with diminishing returns to prevent hyperactivity
 1340:         float total = physical + mental + social;
 1341:         return MathHelper.clamp(total / (1f + total * 0.3f), 0f, 1f);
 1343: 
 1345:         float dt = MathHelper.clamp(deltaTicks / 20f, 0.05f, 5f);
 1346: 
 1347:         float normalizedPhysical = Math.min(1f, physicalActivity * 0.4f);
 1348:         float normalizedMental = Math.min(1f, mentalActivity * 0.3f);
 1349:         float normalizedSocial = Math.min(1f, socialActivity * 0.3f);
 1350:         float normalizedRest = Math.min(1f, restActivity * 0.5f);
 1351: 
 1352:         float ambientSocial = sampleAmbientSocialComfort(now);
 1353:         float bondFactor = normalizedBondStrength();
 1354: 
 1355:         float physicalLoad = Math.max(normalizedPhysical, recentPhysicalBurst);
 1356:         float physicalDrain = physicalLoad * (0.45f + physicalLoad * 0.25f) * dt;
 1357:         float recoveryBase = 0.03f + (1f - physicalLoad) * 0.08f + socialCharge * 0.01f;
 1358:         float physicalRecovery = recoveryBase * dt;
 1359:         float restBias = (0.04f + (1f - physicalStamina) * 0.12f) * normalizedRest * dt;
 1360:         physicalRecovery += restBias;
 1361:         physicalStamina = MathHelper.clamp(physicalStamina + physicalRecovery - physicalDrain, 0.05f, 1f);
 1362:         recentPhysicalBurst = Math.max(0f, recentPhysicalBurst - dt * 0.6f);
 1363: 
 1364:         float calmMood = moodBlend.getOrDefault(PetComponent.Mood.CALM, 0f);
 1365:         float focusMood = moodBlend.getOrDefault(PetComponent.Mood.CURIOUS, 0f);
 1366:         float mentalDrain = normalizedMental * (0.5f + normalizedMental * 0.2f) * dt;
 1367:         float mentalRecovery = (0.025f + (1f - normalizedMental) * 0.05f + calmMood * 0.04f + focusMood * 0.02f) * dt;
 1368:         mentalFocus = MathHelper.clamp(mentalFocus + mentalRecovery - mentalDrain, 0.05f, 1f);
 1369: 
 1370:         float familiarityPenalty = MathHelper.clamp(0.25f - ambientSocial * 0.18f, 0.05f, 0.25f);
 1371:         float socialGain = (normalizedSocial * (0.55f + bondFactor * 0.25f)) * dt;
 1372:         float ambientBoost = ambientSocial * 0.05f * dt;
 1373:         float socialDecay = (0.02f + familiarityPenalty * normalizedSocial + (1f - ambientSocial) * 0.02f) * dt;
 1374:         socialCharge = MathHelper.clamp(socialCharge + socialGain + ambientBoost - socialDecay, 0.1f, 1f);
 1375: 
 1376:         energyProfileDirty = true;
 1378: 
 1380:         float comfort = 0f;
 1381: 
 1382:         long lastSocialTick = parent.getStateData(PetComponent.StateKeys.LAST_SOCIAL_BUFFER_TICK, Long.class, 0L);
 1384:             comfort = Math.max(comfort, 0.4f);
 1386: 
 1387:         long lastPackTick = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_TICK, Long.class, 0L);
 1388:         float lastPackStrength = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_STRENGTH, Float.class, 0f);
 1389:         float lastPackWeighted = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_WEIGHTED_STRENGTH, Float.class, 0f);
 1390:         int lastPackAllies = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_ALLIES, Integer.class, 0);
 1392:             float familiarity = Math.max(lastPackStrength, lastPackWeighted);
 1393:             comfort = Math.max(comfort, 0.55f + MathHelper.clamp(familiarity, 0f, 1f) * 0.35f);
 1395: 
 1396:         PlayerEntity owner = parent.getOwner();
 1397:         MobEntity petEntity = parent.getPetEntity();
 1399:             double distSq = owner.squaredDistanceTo(petEntity);
 1401:                 float bondFactor = normalizedBondStrength();
 1402:                 float proximityScale = (float) (1.0 - Math.min(1.0, distSq / 144.0));
 1403:                 comfort = Math.max(comfort, (0.25f + bondFactor * 0.25f) * proximityScale);
 1406: 
 1407:         return MathHelper.clamp(comfort, 0f, 1f);
 1409: 
 1411:         float normalizedPhysical = Math.min(1f, physicalActivity * 0.4f);
 1412:         float normalizedMental = Math.min(1f, mentalActivity * 0.3f);
 1413:         float normalizedSocial = Math.min(1f, socialActivity * 0.3f);
 1414: 
 1415:         cachedEnergyProfile = new BehaviouralEnergyProfile(
 1416:             behavioralMomentum,
 1417:             physicalActivity,
 1418:             mentalActivity,
 1419:             socialActivity,
 1420:             normalizedPhysical,
 1421:             normalizedMental,
 1422:             normalizedSocial,
 1423:             physicalStamina,
 1424:             mentalFocus,
 1425:             socialCharge
 1426:         );
 1427:         energyProfileDirty = false;
 1428:         parent.notifyEnergyProfileUpdated();
 1430: 
 1432:         return MathHelper.clamp(parent.getBondStrength() / 4000f, 0f, 1f);
 1434:     
 1435:     /**
 1436:      * Calculates inertia factor for smooth momentum transitions.
 1437:      */
 1439:         // Base inertia from nature (resilient pets change energy slower)
 1440:         float resilience = Math.max(0.1f, parent.getNatureResilienceMultiplier());
 1441:         float baseInertia = 0.05f / resilience;
 1442: 
 1443:         // Scale by time delta for frame-independent behavior (wider window for multi-second bursts)
 1444:         float timeFactor = MathHelper.clamp(deltaTicks / 20f, 0.5f, 6f);
 1445: 
 1446:         // Accelerate transitions when momentum is far from target or has been moving recently
 1447:         float gapUrgency = MathHelper.clamp(momentumGap * 3.5f, 0f, 3.5f);
 1448:         float inertiaPulse = MathHelper.clamp(momentumInertia * 12f, 0f, 3f);
 1449:         float urgency = 1f + gapUrgency + inertiaPulse;
 1450: 
 1451:         return MathHelper.clamp(baseInertia * timeFactor * urgency, 0.001f, 0.5f);
 1453:     
 1454:     /**
 1455:      * Generates organic variation for lifelike momentum fluctuations.
 1456:      * Uses multiple frequency sine waves for natural-looking "breathing" behavior.
 1457:      */
 1459:         long petSeed = parent.getStablePerPetSeed();
 1460: 
 1461:         // Multiple sine waves at different frequencies for organic movement
 1462:         double timeSeconds = now * 0.001; // Scale down for smoother variation
 1463: 
 1464:         double microPhase = timeSeconds * 60 + normalizedPhaseFromSeed(petSeed, 0);
 1465:         double mesoPhase = timeSeconds * 12 + normalizedPhaseFromSeed(petSeed, 21);
 1466:         double macroPhase = timeSeconds * 3 + normalizedPhaseFromSeed(petSeed, 42);
 1467: 
 1468:         float microVariation = (float)Math.sin(microPhase) * 0.015f;
 1469:         float mesoVariation = (float)Math.sin(mesoPhase) * 0.025f;
 1470:         float macroVariation = (float)Math.sin(macroPhase) * 0.035f;
 1471: 
 1472:         // Personality-based variation intensity
 1473:         float volatility = parent.getNatureVolatilityMultiplier();
 1474:         float variationScale = 0.5f + volatility * 0.5f;
 1475: 
 1476:         return (microVariation + mesoVariation + macroVariation) * variationScale;
 1478: 
 1480:         long rotated = Long.rotateLeft(seed, rotation);
 1481:         long mask = (1L << 53) - 1;
 1482:         long fractionBits = rotated & mask;
 1483:         double normalized = fractionBits / (double)(1L << 53);
 1484:         return normalized * (Math.PI * 2);
 1486:     
 1487:     /**
 1488:      * Decays activity accumulators over time.
 1489:      */
 1491:         float decayFactor = Math.max(0f, 1f - deltaTicks * 0.005f);
 1492:         
 1493:         // Different decay rates for different activities
 1494:         physicalActivity *= Math.pow(decayFactor, 1.2);  // Physical decays faster
 1495:         mentalActivity *= Math.pow(decayFactor, 0.8);    // Mental decays slower
 1496:         socialActivity *= Math.pow(decayFactor, 1.0);    // Social decays normally
 1497:         restActivity *= Math.pow(decayFactor, 0.5);      // Rest lingers to keep recovery bias for a bit
 1498: 
 1499:         // Clear near-zero values to prevent float drift
 1500:         if (physicalActivity < 0.001f) physicalActivity = 0f;
 1501:         if (mentalActivity < 0.001f) mentalActivity = 0f;
 1502:         if (socialActivity < 0.001f) socialActivity = 0f;
 1503:         if (restActivity < 0.001f) restActivity = 0f;
 1505:     
 1506:     /**
 1507:      * Applies behavioral momentum influence to mood blend.
 1508:      */
 1510:         // High momentum (hyperactive)
 1512:             float hyperFactor = (behavioralMomentum - 0.65f) / 0.35f;
 1513:             moodBlend.compute(PetComponent.Mood.CALM, (k, v) -> 
 1514:                 v == null ? 0f : v * (1f - hyperFactor * 0.4f));
 1515:             moodBlend.compute(PetComponent.Mood.RESTLESS, (k, v) -> 
 1516:                 (v == null ? 0f : v) + hyperFactor * 0.2f);
 1518:         // Low momentum (tired)
 1520:             float tiredFactor = (0.35f - behavioralMomentum) / 0.35f;
 1521:             moodBlend.compute(PetComponent.Mood.CALM, (k, v) -> 
 1522:                 (v == null ? 0f : v) + tiredFactor * 0.3f);
 1523:             moodBlend.compute(PetComponent.Mood.PLAYFUL, (k, v) -> 
 1524:                 v == null ? 0f : v * (1f - tiredFactor * 0.5f));
 1527:     
 1530:             return Math.max(0.08f, previousStrength * 0.25f);
 1532:         double mean = dominantHistory.stream().mapToDouble(Float::floatValue).average().orElse(0.0);
 1533:         double variance = dominantHistory.stream()
 1535:                 double diff = (v - mean);
 1536:                 return diff * diff;
 1538:             .average().orElse(0.0);
 1539:         // Safety: ensure variance is non-negative before sqrt
 1540:         variance = Math.max(0.0, variance);
 1541:         float stddev = (float) Math.sqrt(variance);
 1542:         // Clamp stddev to reasonable range for mood switching
 1543:         stddev = MathHelper.clamp(stddev, 0.01f, 0.5f);
 1544:         return Math.max(0.05f, stddev); // Phase 2 tuning
 1546: 
 1548:         float total = 0f;
 1550:             total += Math.max(0f, value);
 1554:                 blend.put(mood, mood == PetComponent.Mood.CALM ? 1f : 0f);
 1556:             return;
 1559:             entry.setValue(Math.max(0f, entry.getValue()) / total);
 1562: 
 1564:         float total = 0f;
 1566:             total += Math.max(0f, value);
 1569:             blend.clear();
 1570:             return;
 1573:             entry.setValue(Math.max(0f, entry.getValue()) / total);
 1576: 
 1577:     private float computePaletteDelta(List<PetComponent.WeightedEmotionColor> previous,
 1579:         EnumMap<PetComponent.Emotion, Float> previousMap = new EnumMap<>(PetComponent.Emotion.class);
 1582:                 previousMap.put(stop.emotion(), stop.weight());
 1585:         EnumMap<PetComponent.Emotion, Float> nextMap = new EnumMap<>(PetComponent.Emotion.class);
 1588:                 nextMap.put(stop.emotion(), stop.weight());
 1591:         float delta = 0f;
 1593:             float previousValue = previousMap.getOrDefault(entry.getKey(), 0f);
 1594:             delta += Math.abs(entry.getValue() - previousValue);
 1598:                 delta += Math.abs(entry.getValue());
 1601:         return delta;
 1603: 
 1607:                 paletteBlend.clear();
 1609:             stagePalette(Collections.emptyList());
 1610:             return;
 1612: 
 1613:         EnumMap<PetComponent.Emotion, Float> target = new EnumMap<>(PetComponent.Emotion.class);
 1614:         float total = 0f;
 1616:             float weight = Math.max(0f, candidate.signal);
 1618:                 continue;
 1620:             target.merge(candidate.record.emotion, weight, Float::sum);
 1621:             total += weight;
 1623: 
 1625:             paletteBlend.clear();
 1626:             stagePalette(Collections.emptyList());
 1627:             return;
 1629: 
 1631:             entry.setValue(entry.getValue() / total);
 1633: 
 1634:         double momentum = MathHelper.clamp((float) cachedMomentum, 0f, 1f);
 1635:         EnumMap<PetComponent.Emotion, Float> blended = new EnumMap<>(PetComponent.Emotion.class);
 1637:             float previous = paletteBlend.getOrDefault(emotion, 0f);
 1638:             float targetWeight = target.getOrDefault(emotion, 0f);
 1639:             float updated = previous + (targetWeight - previous) * (float) momentum;
 1641:                 blended.put(emotion, updated);
 1644: 
 1645:         paletteBlend.clear();
 1646:         paletteBlend.putAll(blended);
 1647:         normalizePalette(paletteBlend);
 1648: 
 1650:             stagePalette(Collections.emptyList());
 1651:             return;
 1653: 
 1654:         List<Map.Entry<PetComponent.Emotion, Float>> entries = new ArrayList<>(paletteBlend.entrySet());
 1655:         entries.sort((a, b) -> Float.compare(b.getValue(), a.getValue()));
 1656:         int limit = Math.min(entries.size(), 4);
 1657:         List<PetComponent.WeightedEmotionColor> stops = new ArrayList<>(limit);
 1658:         float stopsTotal = 0f;
 1660:             Map.Entry<PetComponent.Emotion, Float> entry = entries.get(i);
 1661:             float weight = Math.max(0f, entry.getValue());
 1662:             stopsTotal += weight;
 1663:             TextColor color = PetComponent.getEmotionColor(entry.getKey());
 1664:             stops.add(new PetComponent.WeightedEmotionColor(entry.getKey(), weight, color));
 1666: 
 1668:             stagePalette(Collections.emptyList());
 1669:             return;
 1671: 
 1672:         float invTotal = 1f / stopsTotal;
 1673:         List<PetComponent.WeightedEmotionColor> normalized = new ArrayList<>(stops.size());
 1675:             normalized.add(new PetComponent.WeightedEmotionColor(stop.emotion(), stop.weight() * invTotal, stop.color()));
 1677: 
 1678:         List<PetComponent.WeightedEmotionColor> finalStops = List.copyOf(normalized);
 1679:         stagePalette(finalStops);
 1681: 
 1683:         List<PetComponent.WeightedEmotionColor> target = palette == null
 1684:                 ? Collections.emptyList()
 1685:                 : palette;
 1686:         boolean matchesCurrent = computePaletteDelta(currentPaletteStops, target) <= EPSILON
 1687:                 && target.size() == currentPaletteStops.size()
 1688:                 && target.equals(currentPaletteStops);
 1690:             stagedPaletteStops = target;
 1691:             hasPendingPalette = false;
 1692:             return;
 1694: 
 1695:         boolean matchesStaged = computePaletteDelta(stagedPaletteStops, target) <= EPSILON * 0.05f
 1696:                 && target.size() == stagedPaletteStops.size()
 1697:                 && target.equals(stagedPaletteStops);
 1699:             return;
 1701: 
 1702:         stagedPaletteStops = target;
 1703:         hasPendingPalette = true;
 1705: 
 1708:             return;
 1711:             applyPendingPalette(currentTime);
 1712:             return;
 1714: 
 1715:         int breathingCycle = getBreathingCycleLength(level);
 1717:             applyPendingPalette(currentTime);
 1718:             return;
 1720: 
 1721:         long elapsed = currentTime - lastPaletteCommitTime;
 1723:             applyPendingPalette(currentTime);
 1724:             return;
 1726: 
 1727:         long animationTime = updateInterval > 0 ? (currentTime / updateInterval) * updateInterval : currentTime;
 1728:         long phase = breathingCycle > 0 ? animationTime % breathingCycle : 0L;
 1729:         boolean atCycleBoundary = phase < updateInterval;
 1730: 
 1732:             applyPendingPalette(currentTime);
 1735: 
 1737:         currentPaletteStops = stagedPaletteStops;
 1738:         hasPendingPalette = false;
 1739:         paletteGeneration++;
 1740:         paletteCommittedOnce = true;
 1741:         lastPaletteCommitTime = currentTime;
 1743: 
 1745:         float total = 0f;
 1746:         float accum = 0f;
 1748:             float weight = Math.max(0f, candidate.signal);
 1750:                 continue;
 1752:             total += weight;
 1753:             accum += weight * MathHelper.clamp(candidate.record.intensity, 0f, 1f);
 1755:         float target = total > EPSILON ? accum / total : 0f;
 1756:         target = MathHelper.clamp(target, 0f, 1f);
 1757:         animationIntensity = MathHelper.lerp(0.35f, animationIntensity, target);
 1759: 
 1761:         return computeBreathingDuration(level, BASE_BREATHING_SPEEDS);
 1763: 
 1766:             return 0;
 1768:         int index = Math.min(level - 1, baseDurations.length - 1);
 1769:         int base = baseDurations[index];
 1770:         float intensity = MathHelper.clamp(animationIntensity, 0f, 1f);
 1771:         
 1772:         // Intensity scaling: higher intensity = faster breathing (more agitated)
 1773:         float minScale;
 1775:             minScale = 0.8f;   // Level 1: subtle variation
 1777:             minScale = 0.66f;  // Level 2: moderate variation
 1779:             minScale = 0.55f;  // Level 3: dramatic variation
 1781:         float scale = MathHelper.lerp(intensity, 1f, minScale);
 1782:         
 1783:         // Nature modifier: volatile pets breathe faster, calm pets slower
 1784:         float volatilityMod = parent.getNatureVolatilityMultiplier();
 1785:         scale *= (2.0f - volatilityMod); // Inverse: high volatility = lower scale = faster breathing
 1786:         scale = MathHelper.clamp(scale, 0.4f, 1.2f);
 1787:         
 1788:         int scaled = Math.round(base * scale);
 1789:         return Math.max(40, scaled);
 1791: 
 1794:             return;
 1796: 
 1797:         Map<PetComponent.Emotion, Candidate> lookup = weighted.stream()
 1798:                 .collect(Collectors.toMap(c -> c.record.emotion, c -> c));
 1799: 
 1800:         List<OpponentConflict> conflicts = new ArrayList<>();
 1802:             EnumSet<PetComponent.Emotion> opponents = opponentPairs.get(candidate.record.emotion);
 1803:             if (opponents == null || opponents.isEmpty()) continue;
 1805:                 if (!lookup.containsKey(opponent)) continue;
 1806:                 if (candidate.record.emotion.ordinal() >= opponent.ordinal()) continue;
 1807:                 Candidate other = lookup.get(opponent);
 1808:                 float combined = candidate.signal + other.signal;
 1809:                 conflicts.add(new OpponentConflict(candidate, other, combined));
 1812: 
 1813:         conflicts.sort(Comparator.comparingDouble((OpponentConflict c) -> c.combinedWeight).reversed());
 1814:         
 1815:         // Nature modifiers affect conflict resolution
 1816:         float volatilityMod = parent.getNatureVolatilityMultiplier();  // 0.5-1.5
 1817:         float resilienceMod = parent.getNatureResilienceMultiplier();  // 0.5-1.5
 1818:         
 1820:             Candidate first = conflict.a;
 1821:             Candidate second = conflict.b;
 1822:             float difference = Math.abs(first.signal - second.signal);
 1824:                 continue;
 1826: 
 1827:             Candidate donor;
 1828:             Candidate receiver;
 1830:                 donor = first;
 1831:                 receiver = second;
 1833:                 donor = second;
 1834:                 receiver = first;
 1836: 
 1837:             float baseTransfer = Math.min(cachedOpponentTransferMax, 0.15f + 0.1f * difference);
 1838:             float natureScale = (volatilityMod / resilienceMod);
 1839:             float transferFactor = baseTransfer * MathHelper.clamp(natureScale, 0.70f, 1.30f); // Phase 2 tuning
 1840:             transferFactor = MathHelper.clamp(transferFactor, 0.05f, 0.45f);
 1841:             
 1842:             float transfer = donor.signal * transferFactor;
 1843:             if (transfer <= EPSILON) continue;
 1844: 
 1845:             float avgConfidence = (first.record.appraisalConfidence + second.record.appraisalConfidence) * 0.5f;
 1846:             float reboundBase = 0.2f + cachedReboundGain * avgConfidence;
 1847:             float reboundGain = reboundBase * resilienceMod;
 1848:             float rebound = transfer * MathHelper.clamp(reboundGain, 0.1f, 0.5f);
 1849: 
 1850:             donor.signal = Math.max(0f, donor.signal - transfer);
 1851:             receiver.signal = Math.min(weightCap, receiver.signal + transfer * 0.85f);
 1852:             donor.signal = Math.max(0f, donor.signal + rebound * 0.2f);
 1855: 
 1858:             return 0f;
 1860:         float cadence = record.cadenceEMA > 0f ? record.cadenceEMA : cachedHabituationBase;
 1861:         float age = Math.max(0f, now - record.lastEventTime);
 1862:         return (float) Math.exp(-age / Math.max(1f, cadence));
 1864: 
 1866:         long bond = parent.getBondStrength();
 1867:         float guardModifier = parent.getNatureGuardModifier();
 1868:         double bondZ = (bond - 2000.0) / cachedRelationshipVariance;
 1869:         float bondMultiplier = (float) MathHelper.clamp(1.0 + bondZ * 0.35, 0.75, 1.25);
 1870:         Long lastPet = parent.getStateData(PetComponent.StateKeys.LAST_PET_TIME, Long.class);
 1871:         float carePulse = 0f;
 1873:             float age = Math.max(0f, now - lastPet);
 1874:             carePulse = (float) Math.exp(-age / cachedCarePulseHalfLife);
 1876:         float careMultiplier = 0.85f + 0.3f * carePulse;
 1877:         float relationshipTarget = MathHelper.clamp(bondMultiplier * careMultiplier, 0.75f, 1.25f);
 1878:         float guardBias = getNatureGuardBias(record.emotion);
 1879:         float tunedRelationship = MathHelper.clamp(relationshipTarget * guardModifier * guardBias, 0.6f, 1.6f);
 1880:         record.relationshipGuard = MathHelper.lerp(0.25f,
 1881:             record.relationshipGuard <= 0f ? RELATIONSHIP_BASE : record.relationshipGuard,
 1882:             tunedRelationship);
 1883: 
 1884:         long lastDangerTick = parent.getStateData(PetComponent.StateKeys.THREAT_LAST_DANGER, Long.class, Long.MIN_VALUE);
 1885:         int dangerStreak = parent.getStateData(PetComponent.StateKeys.THREAT_SENSITIZED_STREAK, Integer.class, 0);
 1886:         float dangerMultiplier = 1.0f;
 1888:             float dangerAge = Math.max(0f, now - lastDangerTick);
 1889:             float streakBias = Math.min(0.35f, dangerStreak * 0.05f);
 1890:             float decay = (float) Math.exp(-dangerAge / cachedDangerHalfLife);
 1891:             dangerMultiplier = 0.85f + streakBias + 0.2f * decay;
 1893:         float dangerTarget = MathHelper.clamp(dangerMultiplier, 0.75f, 1.35f);
 1894:         float tunedDanger = MathHelper.clamp(dangerTarget * guardModifier * guardBias, 0.6f, 1.7f);
 1895:         record.dangerWindow = MathHelper.lerp(0.25f,
 1896:             record.dangerWindow <= 0f ? DANGER_BASE : record.dangerWindow,
 1897:             tunedDanger);
 1898: 
 1899:         // Appraisal confidence trends toward baseline with volatility awareness
 1900:         float volatility = record.volatilityEMA;
 1901:         float volatilityPenalty = MathHelper.clamp(volatility * 0.6f, 0f, 0.35f);
 1902:         float confidenceTarget = MathHelper.clamp(APPRAISAL_BASE - volatilityPenalty + 0.1f * (record.relationshipGuard - 1f), 0.4f, 0.95f);
 1903:         record.appraisalConfidence = MathHelper.lerp(0.1f, record.appraisalConfidence <= 0f ? APPRAISAL_BASE : record.appraisalConfidence, confidenceTarget);
 1904: 
 1905:         // Contagion share decays naturally
 1906:         float decayStretch = getNatureQuirkContagionDecayModifier(record.emotion);
 1907:         float contagionDecay = (float) Math.exp(-delta / Math.max(60f, 240f * decayStretch));
 1908:         record.contagionShare *= contagionDecay;
 1909: 
 1910:         lastRelationshipGuardObserved = Math.max(lastRelationshipGuardObserved, record.relationshipGuard);
 1911:         lastDangerWindowObserved = Math.max(lastDangerWindowObserved, record.dangerWindow);
 1913: 
 1916:             return fallback;
 1918:         // Safety: single element array
 1920:             return data[0];
 1922:         // Clamp quantile to valid range [0, 1]
 1923:         quantile = MathHelper.clamp(quantile, 0f, 1f);
 1924:         int targetIndex = (int) MathHelper.clamp(Math.round((length - 1) * quantile), 0, length - 1);
 1925:         int left = 0;
 1926:         int right = length - 1;
 1927:         
 1928:         // Quickselect algorithm with safety bounds
 1929:         int iterations = 0;
 1930:         int maxIterations = length * 2; // Prevent infinite loops
 1932:             int pivotIndex = partition(data, left, right, left + (right - left) / 2);
 1934:                 return data[targetIndex];
 1937:                 right = pivotIndex - 1;
 1939:                 left = pivotIndex + 1;
 1941:             iterations++;
 1943:         // Bounds check before returning
 1944:         return (left >= 0 && left < length) ? data[left] : fallback;
 1946: 
 1948:         // Bounds validation
 1950:             return left; // Safe fallback
 1952:         
 1953:         float pivotValue = data[pivotIndex];
 1954:         swap(data, pivotIndex, right);
 1955:         int storeIndex = left;
 1958:                 swap(data, storeIndex, i);
 1959:                 storeIndex++;
 1962:         swap(data, right, storeIndex);
 1963:         return storeIndex;
 1965: 
 1968:             return;
 1970:         // Bounds check to prevent ArrayIndexOutOfBoundsException
 1972:             return; // Silent fail for safety
 1974:         float temp = data[i];
 1975:         data[i] = data[j];
 1976:         data[j] = temp;
 1978: 
 1981:             return data;
 1983:         int newSize = data.length > 0 ? data.length : 1;
 1985:             newSize <<= 1;
 1987:                 newSize = required;
 1988:                 break;
 1992:             newSize = required;
 1994:         return Arrays.copyOf(data, newSize);
 1996: 
 1997:     @SuppressWarnings("unused")
 2000:             return x < edge0 ? 0f : 1f;
 2002:         float t = MathHelper.clamp((x - edge0) / (edge1 - edge0), 0f, 1f);
 2003:         return t * t * (3f - 2f * t);
 2005: 
 2007:         scratchBudgets = ensureCapacity(scratchBudgets, active.size());
 2008:         scratchBudgetCount = active.size();
 2010:             scratchBudgets[i] = active.get(i).impactBudget;
 2012:         float dynamic = selectQuantile(scratchBudgets, scratchBudgetCount, 0.95f, DEFAULT_IMPACT_CAP);
 2013:         return Math.max(DEFAULT_IMPACT_CAP, dynamic);
 2015: 
 2017:         return computeImpactCap(new ArrayList<>(emotionRecords.values()));
 2019: 
 2021:         float impactCap = getImpactCap();
 2022:         float contagionModifier = parent.getNatureContagionModifier();
 2023:         float scaled = impactCap * 0.1f * bondFactor * contagionModifier;
 2024:         float min = 0.05f * Math.min(1f, contagionModifier);
 2025:         float max = 0.6f * Math.max(1f, contagionModifier);
 2026:         return MathHelper.clamp(scaled, min, max);
 2028: 
 2030:         ensureConfigCache();
 2031:         return cachedLevelThresholds;
 2033: 
 2035:         float bias = getProfileScale(emotion, 0.55f, 0.35f, 0f, 0.20f, 1.60f); // Phase 2 tuning
 2036:         return MathHelper.clamp(bias, 0.0f, 2.0f);
 2038: 
 2040:         float bias = getProfileScale(emotion, 0.5f, 0.3f, 0.15f, 0.30f, 1.50f); // Phase 2 tuning
 2041:         return MathHelper.clamp(bias, 0.0f, 2.0f);
 2043: 
 2045:         float bias = getProfileScale(emotion, 0.45f, 0.25f, 0.2f, 0.6f, 1.6f);
 2046:         return MathHelper.clamp(bias, 0.0f, 2.0f);
 2048: 
 2050:         float bias = getProfileScale(emotion, 0.25f, 0.15f, 0.1f, 0.7f, 1.4f);
 2051:         return MathHelper.clamp(bias, 0.0f, 2.0f);
 2053: 
 2055:         float modifier = getProfileScale(emotion, 0f, 0f, -0.45f, 0.55f, 1.1f);
 2056:         return MathHelper.clamp(modifier, -1.0f, 2.0f);
 2058: 
 2060:         // Quirk emotions decay contagion at different rates based on nature profile
 2061:         float modifier = getProfileScale(emotion, 0f, 0f, 0.6f, 0.6f, 1.6f);
 2062:         return MathHelper.clamp(modifier, 0.1f, 3.0f); // Ensure positive decay modifier
 2064:     
 2066:         // How long emotions persist based on nature alignment
 2067:         float modifier = getProfileScale(emotion, 0.4f, 0.25f, 0.15f, 0.6f, 1.5f);
 2068:         return MathHelper.clamp(modifier, 0.5f, 2.0f);
 2070:     
 2072:         // How much fresh emotions spike based on nature alignment
 2073:         float modifier = getProfileScale(emotion, 0.5f, 0.3f, 0.2f, 0.7f, 1.4f);
 2074:         return MathHelper.clamp(modifier, 0.5f, 1.5f);
 2076: 
 2077:     /**
 2078:      * Check if the condition that triggers this emotion is still present.
 2079:      * Used for condition-aware decay and persistence bonuses.
 2080:      */
 2082:         ensureConfigCache();
 2084:             case SAUDADE:
 2085:             case HIRAETH:
 2086:                 return checkLoneliness(emotion, now);
 2087: 
 2088:             case FOREBODING:
 2089:             case STARTLE:
 2090:             case ANGST:
 2091:                 // Danger: check if danger occurred recently
 2092:                 long lastDanger = parent.getStateData(PetComponent.StateKeys.THREAT_LAST_DANGER, Long.class, Long.MIN_VALUE);
 2093:                 if (lastDanger == Long.MIN_VALUE) return false;
 2094:                 return (now - lastDanger) < DANGER_HALF_LIFE; // Within danger window
 2095: 
 2096:             case GUARDIAN_VIGIL:
 2097:             case PROTECTIVE:
 2098:                 return checkOwnerDanger(now);
 2099: 
 2100:             case CONTENT:
 2101:             case CHEERFUL:
 2102:                 return hasPositiveComfort(emotion, now);
 2103: 
 2104:             case ECHOED_RESONANCE:
 2105:                 // Echoed Resonance persists when both bond AND danger are present
 2106:                 long bondStrength = parent.getBondStrength();
 2107:                 long lastDangerEchoed = parent.getStateData(PetComponent.StateKeys.THREAT_LAST_DANGER, Long.class, Long.MIN_VALUE);
 2108:                 return bondStrength > 3000 && (lastDangerEchoed != Long.MIN_VALUE && (now - lastDangerEchoed) < DANGER_HALF_LIFE * 1.5f);
 2109: 
 2110:             case PACK_SPIRIT:
 2111:                 return checkPackSpiritProximity(now);
 2112: 
 2113:             case ARCANE_OVERFLOW:
 2114:                 return hasArcaneMomentum(now);
 2115: 
 2116:             default:
 2117:                 // Most emotions don't have persistent conditions
 2118:                 return false;
 2121: 
 2123:         long lastHurtTick = parent.getStateData(PetComponent.StateKeys.OWNER_LAST_HURT_TICK, Long.class, 0L);
 2124:         float storedSeverity = parent.getStateData(PetComponent.StateKeys.OWNER_LAST_HURT_SEVERITY, Float.class, 0f);
 2125:         long lastLowHealthTick = parent.getStateData(PetComponent.StateKeys.OWNER_LAST_LOW_HEALTH_TICK, Long.class, 0L);
 2126:         long lastHazardTick = parent.getStateData(PetComponent.StateKeys.OWNER_LAST_STATUS_HAZARD_TICK, Long.class, 0L);
 2127:         float lastHazardSeverity = parent.getStateData(PetComponent.StateKeys.OWNER_LAST_STATUS_HAZARD_SEVERITY,
 2128:             Float.class, 0f);
 2129: 
 2131:             long elapsed = now - lastHurtTick;
 2134:                     return true;
 2137:                     return true;
 2141: 
 2143:             return true;
 2145: 
 2146:         PlayerEntity owner = parent.getOwner();
 2148:             float hazardSeverity = computeStatusHazardSeverity(owner);
 2150:                 parent.setStateData(PetComponent.StateKeys.OWNER_LAST_STATUS_HAZARD_TICK, now);
 2151:                 parent.setStateData(PetComponent.StateKeys.OWNER_LAST_STATUS_HAZARD_SEVERITY, hazardSeverity);
 2152:                 lastHazardTick = now;
 2153:                 lastHazardSeverity = hazardSeverity;
 2155:                 parent.clearStateData(PetComponent.StateKeys.OWNER_LAST_STATUS_HAZARD_TICK);
 2156:                 parent.clearStateData(PetComponent.StateKeys.OWNER_LAST_STATUS_HAZARD_SEVERITY);
 2157:                 lastHazardTick = 0L;
 2158:                 lastHazardSeverity = 0f;
 2161: 
 2164:                 return true;
 2167: 
 2170:                 parent.clearStateData(PetComponent.StateKeys.OWNER_LAST_STATUS_HAZARD_TICK);
 2171:                 parent.clearStateData(PetComponent.StateKeys.OWNER_LAST_STATUS_HAZARD_SEVERITY);
 2173:             return false;
 2176:             return true;
 2178: 
 2179:         float ownerHealthRatio = getHealthRatio(owner);
 2180:         OwnerCombatState combatState = OwnerCombatState.get(owner);
 2181:         boolean recentlyDamaged = combatState != null && combatState.recentlyDamaged(now, cachedOwnerDamageWindow);
 2182:         boolean inCombat = combatState != null && combatState.isInCombat();
 2183: 
 2185:             parent.setStateData(PetComponent.StateKeys.OWNER_LAST_LOW_HEALTH_TICK, now);
 2186:             parent.setStateData(PetComponent.StateKeys.OWNER_LAST_HEALTH_RATIO, ownerHealthRatio);
 2188:                 float severity = MathHelper.clamp(1f - ownerHealthRatio, 0f, 1f);
 2189:                 parent.setStateData(PetComponent.StateKeys.OWNER_LAST_HURT_TICK, now);
 2190:                 parent.setStateData(PetComponent.StateKeys.OWNER_LAST_HURT_SEVERITY,
 2191:                     Math.max(storedSeverity, severity));
 2193:             return true;
 2195: 
 2197:             parent.setStateData(PetComponent.StateKeys.OWNER_LAST_LOW_HEALTH_TICK, now);
 2198:             parent.setStateData(PetComponent.StateKeys.OWNER_LAST_HEALTH_RATIO, ownerHealthRatio);
 2200:                 float severity = MathHelper.clamp(1f - ownerHealthRatio, 0f, 1f);
 2201:                 parent.setStateData(PetComponent.StateKeys.OWNER_LAST_HURT_TICK, now);
 2202:                 parent.setStateData(PetComponent.StateKeys.OWNER_LAST_HURT_SEVERITY,
 2203:                     Math.max(storedSeverity, severity));
 2205:             return true;
 2207: 
 2209:             float severity = MathHelper.clamp(1f - ownerHealthRatio, 0f, 1f);
 2210:             parent.setStateData(PetComponent.StateKeys.OWNER_LAST_HURT_TICK, now);
 2211:             parent.setStateData(PetComponent.StateKeys.OWNER_LAST_HURT_SEVERITY,
 2212:                 Math.max(storedSeverity, severity));
 2213:             parent.setStateData(PetComponent.StateKeys.OWNER_LAST_HEALTH_RATIO, ownerHealthRatio);
 2214:             return true;
 2216: 
 2218:             parent.clearStateData(PetComponent.StateKeys.OWNER_LAST_LOW_HEALTH_TICK);
 2220: 
 2221:         return false;
 2223: 
 2225:         long lastNearTick = parent.getStateData(PetComponent.StateKeys.OWNER_LAST_NEARBY_TICK, Long.class, 0L);
 2226:         long lastSeenTick = parent.getStateData(PetComponent.StateKeys.OWNER_LAST_SEEN_TICK, Long.class, 0L);
 2227:         float lastSeenDistance = parent.getStateData(PetComponent.StateKeys.OWNER_LAST_SEEN_DISTANCE, Float.class,
 2228:             Float.MAX_VALUE);
 2229:         String lastSeenDimension = parent.getStateData(PetComponent.StateKeys.OWNER_LAST_SEEN_DIMENSION, String.class, null);
 2230:         long lastSocialTick = parent.getStateData(PetComponent.StateKeys.LAST_SOCIAL_BUFFER_TICK, Long.class, 0L);
 2231:         long lastPackTick = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_TICK, Long.class, 0L);
 2232:         float lastPackStrength = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_STRENGTH, Float.class, 0f);
 2233:         float lastPackWeighted = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_WEIGHTED_STRENGTH, Float.class, 0f);
 2234:         int lastPackAllies = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_ALLIES, Integer.class, 0);
 2235: 
 2237:             return false;
 2239: 
 2240:         PlayerEntity owner = parent.getOwner();
 2241:         MobEntity petEntity = parent.getPetEntity();
 2242:         ServerWorld petWorld = petEntity != null && petEntity.getEntityWorld() instanceof ServerWorld sw ? sw : null;
 2243: 
 2244:         boolean packComfort = hasRecentPackComfort(now, lastPackTick, lastPackStrength, lastPackWeighted, lastPackAllies);
 2246:             packComfort = refreshPackCompanionship(petWorld, petEntity, owner, now);
 2248:                 lastPackTick = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_TICK, Long.class, lastPackTick);
 2251: 
 2253:             return false;
 2255: 
 2256:         long grace = emotion == PetComponent.Emotion.HIRAETH
 2257:             ? cachedLonelyHiraethGraceTicks
 2258:             : cachedLonelySaudadeGraceTicks;
 2259:         long offlineGrace = emotion == PetComponent.Emotion.HIRAETH
 2260:             ? cachedLonelyOfflineHiraethGraceTicks
 2261:             : cachedLonelyOfflineGraceTicks;
 2262: 
 2263:         if (owner != null && petEntity != null && owner.isAlive()
 2265:             double distanceSq = owner.squaredDistanceTo(petEntity);
 2266:             double distance = Math.sqrt(distanceSq);
 2267: 
 2268:             parent.setStateData(PetComponent.StateKeys.OWNER_LAST_SEEN_TICK, now);
 2269:             parent.setStateData(PetComponent.StateKeys.OWNER_LAST_SEEN_DISTANCE, (float) distance);
 2270:             parent.setStateData(PetComponent.StateKeys.OWNER_LAST_SEEN_DIMENSION,
 2271:                 petWorld != null ? petWorld.getRegistryKey().getValue().toString() : null);
 2272: 
 2274:                 parent.setStateData(PetComponent.StateKeys.OWNER_LAST_NEARBY_TICK, now);
 2275:                 parent.setStateData(PetComponent.StateKeys.OWNER_LAST_NEARBY_DISTANCE, (float) distance);
 2276:                 return false;
 2278: 
 2280:                 long sinceProximity = now - Math.max(lastNearTick, lastSeenTick);
 2282:                     return false;
 2285: 
 2286:             lastSeenTick = now;
 2287:             lastSeenDistance = (float) distance;
 2289: 
 2290:         long sinceNear = lastNearTick > 0L ? now - lastNearTick : Long.MAX_VALUE;
 2292:             return false;
 2294: 
 2295:         boolean ownerMissing = owner == null || owner.isRemoved()
 2296:             || petEntity == null
 2297:             || owner.getEntityWorld() != petEntity.getEntityWorld();
 2298: 
 2300:             long reference = Math.max(lastSeenTick, lastNearTick);
 2302:                 return now >= offlineGrace;
 2304:             return now - reference >= offlineGrace;
 2306: 
 2307:         float distance = Float.isFinite(lastSeenDistance) ? lastSeenDistance : Float.MAX_VALUE;
 2308:         boolean farEnough = distance >= cachedLonelyDistanceThreshold;
 2309: 
 2311:             return false;
 2313: 
 2316:                 String currentDimension = petWorld.getRegistryKey().getValue().toString();
 2318:                     long sinceSeen = now - Math.max(lastSeenTick, lastNearTick);
 2319:                     return sinceSeen >= offlineGrace;
 2322:             return farEnough && sinceNear >= grace;
 2324: 
 2325:         return farEnough;
 2327: 
 2329:         long lastPet = parent.getStateData(PetComponent.StateKeys.LAST_PET_TIME, Long.class, 0L);
 2330:         long lastCrouch = parent.getStateData(PetComponent.StateKeys.LAST_CROUCH_CUDDLE_TICK, Long.class, 0L);
 2331:         long lastSocial = parent.getStateData(PetComponent.StateKeys.LAST_SOCIAL_BUFFER_TICK, Long.class, 0L);
 2332:         long lastPlay = parent.getStateData(PetComponent.StateKeys.LAST_PLAY_INTERACTION_TICK, Long.class, 0L);
 2333:         long lastFeed = parent.getStateData(PetComponent.StateKeys.LAST_FEED_TICK, Long.class, 0L);
 2334:         long lastGift = parent.getStateData(PetComponent.StateKeys.LAST_GIFT_TICK, Long.class, 0L);
 2335: 
 2336:         boolean petting = hasRecentCue(lastPet, cachedPositivePetGraceTicks, now);
 2337:         boolean cuddle = hasRecentCue(lastCrouch, cachedPositiveCrouchGraceTicks, now);
 2338:         boolean social = hasRecentCue(lastSocial, cachedPositiveSocialGraceTicks, now);
 2339:         boolean play = hasRecentCue(lastPlay, cachedPositivePlayGraceTicks, now);
 2340:         boolean feed = hasRecentCue(lastFeed, cachedPositiveFeedGraceTicks, now);
 2341:         boolean gift = hasRecentCue(lastGift, cachedPositiveGiftGraceTicks, now);
 2342: 
 2344:             return false;
 2346: 
 2348:             int strongCues = 0;
 2349:             if (petting) strongCues++;
 2350:             if (cuddle) strongCues++;
 2351:             if (play) strongCues++;
 2352:             if (feed) strongCues++;
 2353:             if (gift) strongCues++;
 2354:             return strongCues >= 2 || social;
 2356: 
 2357:         return true;
 2359: 
 2361:         return tick > 0L && (now - tick) <= grace;
 2363: 
 2365:         return lastSocialTick > 0L && (now - lastSocialTick) <= cachedLonelySocialGraceTicks;
 2367: 
 2368:     private boolean hasRecentPackComfort(long now, long lastPackTick, float lastPackStrength,
 2371:             return false;
 2374:             return false;
 2376:         if (lastPackAllies > 0
 2377:             && (lastPackStrength >= cachedLonelyPackStrengthThreshold
 2379:             return true;
 2381:         return lastPackStrength >= cachedLonelyPackStrengthThreshold
 2382:             || lastPackWeighted >= cachedLonelyPackStrengthThreshold;
 2384: 
 2385:     private boolean refreshPackCompanionship(ServerWorld world,
 2386:                                              @Nullable MobEntity petEntity,
 2387:                                              PlayerEntity owner,
 2390:             return false;
 2392: 
 2393:         StateManager manager = StateManager.forWorld(world);
 2394:         PetSwarmIndex swarmIndex = manager.getSwarmIndex();
 2395:         List<PetSwarmIndex.SwarmEntry> entries = swarmIndex.snapshotOwner(owner.getUuid());
 2397:             return false;
 2399: 
 2400:         Vec3d petPos = new Vec3d(petEntity.getX(), petEntity.getY(), petEntity.getZ());
 2401:         double radiusSq = cachedLonelyPackRadiusSquared;
 2402:         int allies = 0;
 2403:         float closenessSum = 0f;
 2404:         float closest = 0f;
 2405:         EnumSet<PetRoleType.RoleArchetype> diversity = EnumSet.noneOf(PetRoleType.RoleArchetype.class);
 2406: 
 2408:             MobEntity other = entry.pet();
 2410:                 continue;
 2412:             PetComponent component = entry.component();
 2414:                 continue;
 2416: 
 2417:             double dx = entry.x() - petPos.x;
 2418:             double dy = entry.y() - petPos.y;
 2419:             double dz = entry.z() - petPos.z;
 2420:             double distSq = dx * dx + dy * dy + dz * dz;
 2422:                 continue;
 2424: 
 2425:             PetRoleType roleType = component.getRoleType(false);
 2427:                 PetRoleType.RoleArchetype archetype = roleType.archetype();
 2429:                     diversity.add(archetype);
 2432: 
 2433:             double distance = Math.sqrt(distSq);
 2434:             double normalized = cachedLonelyPackRadius <= 0d
 2435:                 ? 0d
 2436:                 : MathHelper.clamp(distance / cachedLonelyPackRadius, 0d, 1d);
 2437:             float closeness = MathHelper.clamp(1f - (float) normalized, 0f, 1f);
 2438:             closenessSum += closeness;
 2439:             closest = Math.max(closest, closeness);
 2440:             allies++;
 2442: 
 2444:             return false;
 2446: 
 2447:         float average = MathHelper.clamp(closenessSum / Math.max(1, allies), 0f, 1f);
 2448:         float weighted = MathHelper.clamp(closenessSum, 0f, allies);
 2449:         float strength = MathHelper.clamp(Math.max(average, closest), 0f, 1f);
 2450:         float diversityScore = MathHelper.clamp(diversity.size()
 2451:             / (float) PetRoleType.RoleArchetype.values().length, 0f, 1f);
 2452: 
 2453:         parent.setStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_TICK, now);
 2454:         parent.setStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_STRENGTH, strength);
 2455:         parent.setStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_WEIGHTED_STRENGTH, weighted);
 2456:         parent.setStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_ALLIES, allies);
 2457:         parent.setStateData(PetComponent.StateKeys.PACK_LAST_ROLE_DIVERSITY, diversityScore);
 2458: 
 2459:         return strength >= cachedLonelyPackStrengthThreshold
 2460:             || weighted >= cachedLonelyPackStrengthThreshold;
 2462: 
 2464:         long lastPackTick = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_TICK, Long.class, 0L);
 2465:         float lastStrength = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_STRENGTH, Float.class, 0f);
 2466:         float lastWeighted = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_WEIGHTED_STRENGTH, Float.class, 0f);
 2467:         int lastAllies = parent.getStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_ALLIES, Integer.class, 0);
 2468: 
 2469:         MobEntity petEntity = parent.getPetEntity();
 2471:             return wasRecentPackPresence(now, lastPackTick, lastStrength, lastWeighted, lastAllies);
 2473: 
 2475:             return wasRecentPackPresence(now, lastPackTick, lastStrength, lastWeighted, lastAllies);
 2477: 
 2478:         PlayerEntity owner = parent.getOwner();
 2480:             return wasRecentPackPresence(now, lastPackTick, lastStrength, lastWeighted, lastAllies);
 2482: 
 2483:         StateManager manager = StateManager.forWorld(serverWorld);
 2484:         PetSwarmIndex swarmIndex = manager.getSwarmIndex();
 2485:         List<PetSwarmIndex.SwarmEntry> entries = swarmIndex.snapshotOwner(owner.getUuid());
 2487:             return wasRecentPackPresence(now, lastPackTick, lastStrength, lastWeighted, lastAllies);
 2489: 
 2490:         Vec3d petPos = new Vec3d(petEntity.getX(), petEntity.getY(), petEntity.getZ());
 2491:         double radiusSq = cachedPackSpiritRadius * cachedPackSpiritRadius;
 2492:         int allies = 0;
 2493:         float engagementSum = 0f;
 2494:         EnumSet<PetRoleType.RoleArchetype> roleMix = EnumSet.noneOf(PetRoleType.RoleArchetype.class);
 2495: 
 2497:             MobEntity other = entry.pet();
 2499:                 continue;
 2501:             PetComponent component = entry.component();
 2503:                 continue;
 2505:             double dx = entry.x() - petPos.x;
 2506:             double dy = entry.y() - petPos.y;
 2507:             double dz = entry.z() - petPos.z;
 2508:             double distSq = dx * dx + dy * dy + dz * dz;
 2510:                 continue;
 2512: 
 2513:             PetRoleType roleType = component.getRoleType(false);
 2514:             PetRoleType.RoleArchetype archetype = roleType != null ? roleType.archetype() : PetRoleType.RoleArchetype.UTILITY;
 2515:             roleMix.add(archetype);
 2516: 
 2517:             float closeness = MathHelper.clamp(1f - (float) (distSq / radiusSq), 0f, 1f);
 2518:             float engagement = computePackmateEngagement(component, closeness, archetype);
 2519:             engagementSum += engagement;
 2520:             allies++;
 2522: 
 2524:             float bondBonus = computePackSpiritBondBonus(parent.getBondStrength());
 2525:             float diversity = roleMix.isEmpty() ? 0f : (float) roleMix.size() / PetRoleType.RoleArchetype.values().length;
 2526:             float averageEngagement = allies > 0 ? engagementSum / allies : 0f;
 2527:             averageEngagement = MathHelper.clamp(averageEngagement, 0f, cachedPackSpiritEngagementMax);
 2528:             float finalStrength = MathHelper.clamp(averageEngagement + (cachedPackSpiritDiversityBonus * diversity) + bondBonus,
 2529:                 0f, 1f);
 2530: 
 2531:             parent.setStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_TICK, now);
 2532:             parent.setStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_STRENGTH, finalStrength);
 2533:             parent.setStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_WEIGHTED_STRENGTH,
 2534:                 MathHelper.clamp(engagementSum, 0f, cachedPackSpiritEngagementMax));
 2535:             parent.setStateData(PetComponent.StateKeys.PACK_LAST_NEARBY_ALLIES, allies);
 2536:             parent.setStateData(PetComponent.StateKeys.PACK_LAST_ROLE_DIVERSITY,
 2537:                 MathHelper.clamp(diversity, 0f, 1f));
 2538:             return true;
 2540: 
 2541:         return wasRecentPackPresence(now, lastPackTick, lastStrength, lastWeighted, lastAllies);
 2543: 
 2546:             return false;
 2549:             return false;
 2552:             return lastStrength > 0.05f;
 2554:         return lastStrength > 0.05f || lastWeighted > 0.05f;
 2556: 
 2558:         float roleWeight = cachedPackSpiritRoleWeights.getOrDefault(archetype, 1.0f);
 2559:         float protective = MathHelper.clamp(component.getMoodStrength(PetComponent.Mood.PROTECTIVE), 0f, 1f);
 2560:         float focused = MathHelper.clamp(component.getMoodStrength(PetComponent.Mood.FOCUSED), 0f, 1f);
 2561:         float playful = MathHelper.clamp(component.getMoodStrength(PetComponent.Mood.PLAYFUL), 0f, 1f);
 2562:         float moodContribution = protective * cachedPackSpiritProtectiveWeight
 2563:             + focused * cachedPackSpiritFocusedWeight
 2564:             + playful * cachedPackSpiritPlayfulWeight;
 2565:         float combatBonus = component.isInCombat() ? cachedPackSpiritCombatBonus : 0f;
 2566:         float engagement = cachedPackSpiritBaseContribution
 2567:             + (closeness * cachedPackSpiritClosenessWeight)
 2568:             + moodContribution
 2569:             + combatBonus;
 2570:         engagement *= roleWeight;
 2571:         return MathHelper.clamp(engagement, 0f, cachedPackSpiritEngagementMax);
 2573: 
 2575:         long lastEnchantTick = parent.getStateData(PetComponent.StateKeys.ARCANE_LAST_ENCHANT_TICK, Long.class, 0L);
 2576:         int enchantStreak = parent.getStateData(PetComponent.StateKeys.ARCANE_ENCHANT_STREAK, Integer.class, 0);
 2577:         long lastSurgeTick = parent.getStateData(PetComponent.StateKeys.ARCANE_LAST_SURGE_TICK, Long.class, 0L);
 2578:         float surgeStrength = parent.getStateData(PetComponent.StateKeys.ARCANE_SURGE_STRENGTH, Float.class, 0f);
 2579: 
 2582:                 return true;
 2585: 
 2588:                 return true;
 2591: 
 2592:         MobEntity petEntity = parent.getPetEntity();
 2594:             return false;
 2596: 
 2597:         ServerWorld serverWorld = livingPet.getEntityWorld() instanceof ServerWorld sw ? sw : null;
 2598:         PlayerEntity owner = parent.getOwner();
 2599: 
 2600:         float energy = 0f;
 2601: 
 2603:             energy += MathHelper.clamp(enchantStreak / 4.0f, 0f, 1f) * 0.4f;
 2605: 
 2606:         float petGear = computeEnchantedGearIntensity(livingPet);
 2608:             energy += petGear * cachedArcaneGearPetMultiplier;
 2610: 
 2611:         float petStatus = computeBeneficialStatusIntensity(livingPet);
 2613:             energy += petStatus * cachedArcaneStatusPetMultiplier;
 2615: 
 2617:             float ownerGear = computeEnchantedGearIntensity(owner);
 2619:                 energy += ownerGear * cachedArcaneGearOwnerMultiplier;
 2621:             float ownerStatus = computeBeneficialStatusIntensity(owner);
 2623:                 energy += ownerStatus * cachedArcaneStatusOwnerMultiplier;
 2626: 
 2627:         float ambientEnergy = 0f;
 2629:             BlockPos currentPos = livingPet.getBlockPos();
 2630:             long lastScanTick = parent.getStateData(PetComponent.StateKeys.ARCANE_LAST_SCAN_TICK, Long.class, 0L);
 2631:             float cachedAmbient = parent.getStateData(PetComponent.StateKeys.ARCANE_CACHED_AMBIENT_ENERGY, Float.class, 0f);
 2632:             BlockPos lastScanPos = parent.getStateData(PetComponent.StateKeys.ARCANE_LAST_SCAN_POS, BlockPos.class);
 2633: 
 2634:             boolean usedCache = false;
 2637:                     double movementSq = lastScanPos.toCenterPos().squaredDistanceTo(Vec3d.ofCenter(currentPos));
 2639:                         ambientEnergy = MathHelper.clamp(cachedAmbient, 0f, 1f);
 2640:                         usedCache = true;
 2643:                     ambientEnergy = MathHelper.clamp(cachedAmbient, 0f, 1f);
 2644:                     usedCache = true;
 2647: 
 2648:             StateManager manager = StateManager.forWorld(serverWorld);
 2650:                 StateManager.ArcaneAmbientCache ambientCache = manager.getArcaneAmbientCache();
 2651:                 StateManager.ArcaneAmbientCache.Sample sharedSample = ambientCache.tryGet(
 2652:                     ChunkSectionPos.from(currentPos), currentPos, cachedArcaneOverflowAmbientScanRadius,
 2653:                     now, cachedArcaneScanCooldownTicks, cachedArcaneScanMovementThresholdSquared);
 2655:                     ambientEnergy = MathHelper.clamp(sharedSample.energy(), 0f, 1f);
 2656:                     parent.setStateData(PetComponent.StateKeys.ARCANE_LAST_SCAN_TICK, sharedSample.tick());
 2657:                     parent.setStateData(PetComponent.StateKeys.ARCANE_LAST_SCAN_POS, sharedSample.origin());
 2658:                     parent.setStateData(PetComponent.StateKeys.ARCANE_CACHED_AMBIENT_ENERGY, ambientEnergy);
 2659:                     usedCache = true;
 2662: 
 2664:                 ambientEnergy = sampleArcaneAmbient(serverWorld, currentPos);
 2665:                 StateManager.ArcaneAmbientCache.Sample storedSample = manager.getArcaneAmbientCache().store(
 2666:                     ChunkSectionPos.from(currentPos), currentPos, cachedArcaneOverflowAmbientScanRadius,
 2667:                     now, cachedArcaneScanCooldownTicks, ambientEnergy);
 2668:                 parent.setStateData(PetComponent.StateKeys.ARCANE_LAST_SCAN_TICK, storedSample.tick());
 2669:                 parent.setStateData(PetComponent.StateKeys.ARCANE_LAST_SCAN_POS, storedSample.origin());
 2670:                 parent.setStateData(PetComponent.StateKeys.ARCANE_CACHED_AMBIENT_ENERGY, storedSample.energy());
 2673: 
 2674:         energy = MathHelper.clamp(energy + MathHelper.clamp(ambientEnergy, 0f, 1f), 0f, 1f);
 2675: 
 2677:             parent.setStateData(PetComponent.StateKeys.ARCANE_SURGE_STRENGTH, energy);
 2679: 
 2681:             parent.setStateData(PetComponent.StateKeys.ARCANE_LAST_SURGE_TICK, now);
 2682:             return true;
 2684: 
 2686:             return surgeStrength >= cachedArcaneOverflowMinimumEnergy * 0.5f;
 2688: 
 2689:         return false;
 2691: 
 2693:         float energy = collectArcaneStructureEnergy(world, origin, cachedArcaneOverflowAmbientScanRadius);
 2695:             energy += cachedArcaneAmbientMysticBonus;
 2697:         return MathHelper.clamp(energy, 0f, 1f);
 2699: 
 2701:         float max = Math.max(1f, entity.getMaxHealth());
 2702:         return MathHelper.clamp(entity.getHealth() / max, 0f, 1f);
 2704: 
 2707:             return 0f;
 2709:         float normalized = MathHelper.clamp(bondStrength / 6000f, 0f, 1f);
 2710:         return MathHelper.clamp(normalized * cachedPackSpiritBondBonus, 0f, 0.6f);
 2712: 
 2715:             return 0f;
 2717: 
 2718:         float total = 0f;
 2719:         total += computeStackEnchantments(entity.getMainHandStack());
 2720:         total += computeStackEnchantments(entity.getOffHandStack());
 2722:             total += computeStackEnchantments(entity.getEquippedStack(slot));
 2724:         return MathHelper.clamp(total, 0f, cachedArcaneGearMaxContribution);
 2726: 
 2729:             return 0f;
 2731:         ItemEnchantmentsComponent enchantments = stack.get(DataComponentTypes.ENCHANTMENTS);
 2733:             return 0f;
 2735: 
 2736:         float total = 0f;
 2738:             int level = Math.max(0, enchantments.getLevel(enchantment));
 2739:             float contribution = cachedArcaneGearBaseWeight
 2740:                 + cachedArcaneGearLevelWeight * Math.max(0, level);
 2741:             total += contribution;
 2743:         return Math.max(0f, total);
 2745: 
 2748:             return 0f;
 2750: 
 2751:         float total = 0f;
 2752:         int reference = Math.max(1, cachedArcaneStatusDurationReference);
 2755:                 continue;
 2757:             RegistryEntry<StatusEffect> type = effect.getEffectType();
 2759:                 continue;
 2761:             StatusEffect status = type.value();
 2763:                 continue;
 2765:             int amplifier = Math.max(0, effect.getAmplifier());
 2766:             float durationRatio = MathHelper.clamp(effect.getDuration() / (float) reference, 0f, cachedArcaneStatusDurationCap);
 2767:             float contribution = cachedArcaneStatusBaseWeight
 2768:                 + cachedArcaneStatusAmplifierWeight * (amplifier + 1)
 2769:                 + cachedArcaneStatusDurationWeight * durationRatio;
 2770:             total += contribution;
 2772: 
 2773:         return MathHelper.clamp(total, 0f, cachedArcaneStatusMaxContribution);
 2775: 
 2778:             return 0f;
 2780: 
 2781:         float severity = 0f;
 2782: 
 2784:             float fireSeverity = 0.45f + Math.min(0.35f, entity.getFireTicks() / 200f);
 2785:             severity = Math.max(severity, fireSeverity);
 2787: 
 2789:             float freezeSeverity = 0.35f + Math.min(0.3f, entity.getFrozenTicks() / 140f);
 2790:             severity = Math.max(severity, freezeSeverity);
 2792: 
 2793:         World world = entity.getEntityWorld();
 2795:             BlockPos basePos = entity.getBlockPos();
 2796:             BlockPos.Mutable mutable = new BlockPos.Mutable();
 2797:             float contactHazard = 0f;
 2798: 
 2799:             mutable.set(basePos);
 2800:             contactHazard = Math.max(contactHazard, resolveContactHazardSeverity(world, mutable));
 2801: 
 2802:             mutable.set(basePos.down());
 2803:             contactHazard = Math.max(contactHazard, resolveContactHazardSeverity(world, mutable));
 2804: 
 2806:                 mutable.set(basePos.getX() + direction.getOffsetX(), basePos.getY(), basePos.getZ() + direction.getOffsetZ());
 2807:                 contactHazard = Math.max(contactHazard, resolveContactHazardSeverity(world, mutable));
 2809: 
 2810:             severity = Math.max(severity, contactHazard);
 2812: 
 2815:                 continue;
 2817:             RegistryEntry<StatusEffect> entry = effect.getEffectType();
 2819:                 continue;
 2821:             StatusEffect status = entry.value();
 2823:                 continue;
 2825: 
 2826:             int amplifier = Math.max(0, effect.getAmplifier());
 2827:             float base = 0.2f + 0.08f * (amplifier + 1);
 2828: 
 2830:                 base = 0.75f + 0.12f * (amplifier + 1);
 2832:                 base = 0.55f + 0.08f * (amplifier + 1);
 2834:                 base = 0.35f + 0.05f * amplifier;
 2836:                 base = 0.3f + 0.05f * amplifier;
 2838:                 base = 0.32f + 0.05f * amplifier;
 2840:                 base = 0.4f;
 2842:                 base = 0.28f;
 2844:                 base = 0.25f + 0.04f * amplifier;
 2846:                 base = 0.45f + 0.05f * amplifier;
 2848: 
 2849:             severity = Math.max(severity, MathHelper.clamp(base, 0f, 1f));
 2851: 
 2852:         return MathHelper.clamp(severity, 0f, 1f);
 2854: 
 2856:         return resolveContactHazardSeverity(world, pos, world.getBlockState(pos));
 2858: 
 2860:         float severity = 0f;
 2861: 
 2863:             severity = Math.max(severity, 0.55f);
 2865:             severity = Math.max(severity, 0.42f);
 2867:             severity = Math.max(severity, 0.65f);
 2869:             severity = Math.max(severity, 0.7f);
 2871:             severity = Math.max(severity, 0.38f);
 2873: 
 2876:                 severity = Math.max(severity, 0.5f);
 2879: 
 2881:             severity = Math.max(severity, 0.95f);
 2883: 
 2884:         return severity;
 2886: 
 2888:         int clamped = MathHelper.clamp(radius, 1, 6);
 2890:             return 0f;
 2892:         BlockPos.Mutable mutable = new BlockPos.Mutable();
 2893:         float accumulated = 0f;
 2894:         double normalization = Math.max(1.0d, clamped + 0.5d);
 2895:         double exponent = Math.max(0.25d, cachedArcaneAmbientDistanceExponent);
 2896: 
 2897:         double originCenterX = origin.getX() + 0.5d;
 2898:         double originCenterY = origin.getY() + 0.5d;
 2899:         double originCenterZ = origin.getZ() + 0.5d;
 2900: 
 2904:                     mutable.set(origin.getX() + dx, origin.getY() + dy, origin.getZ() + dz);
 2905:                     BlockPos samplePos = mutable.toImmutable();
 2906:                     BlockState state = world.getBlockState(samplePos);
 2907:                     float weight = resolveArcaneStructureWeight(world, samplePos, state);
 2909:                         continue;
 2911:                     double distance = Math.sqrt(samplePos.getSquaredDistance(originCenterX, originCenterY, originCenterZ));
 2912:                     double normalized = MathHelper.clamp(distance / normalization, 0.0d, 1.0d);
 2913:                     double falloff = Math.pow(1.0d - normalized, exponent);
 2914:                     accumulated += weight * (float) Math.max(0d, falloff);
 2918: 
 2919:         return MathHelper.clamp(accumulated, 0f, cachedArcaneAmbientStructureMaxEnergy);
 2921: 
 2924:             return 0f;
 2926:         Identifier id = Registries.BLOCK.getId(state.getBlock());
 2927:         float baseWeight = 0f;
 2929:             Float configured = cachedArcaneAmbientStructureWeights.get(id);
 2931:                 baseWeight = Math.max(0f, configured);
 2935:             baseWeight = Math.max(0f, cachedArcaneAmbientStructureBaseWeight);
 2938:             return 0f;
 2940: 
 2942:             return baseWeight * Math.max(0f, resolveRespawnAnchorMultiplier(state));
 2945:             return baseWeight * Math.max(0f, resolveBeaconMultiplier(world, pos));
 2948:             return baseWeight * Math.max(0f, resolveSculkCatalystMultiplier(world, pos));
 2950:         return baseWeight;
 2952: 
 2954:         String key = type.getName() + "#" + name;
 2956:             Class<?> current = type;
 2959:                     Field field = current.getDeclaredField(name);
 2960:                     field.setAccessible(true);
 2961:                     return Optional.of(field);
 2963:                     current = current.getSuperclass();
 2966:             return Optional.empty();
 2969: 
 2971:         String key = type.getName() + "#" + name;
 2973:             Class<?> current = type;
 2976:                     Method method = current.getDeclaredMethod(name);
 2977:                     method.setAccessible(true);
 2978:                     return Optional.of(method);
 2980:                     current = current.getSuperclass();
 2984:                 Method method = type.getMethod(name);
 2985:                 method.setAccessible(true);
 2986:                 return Optional.of(method);
 2988:                 return Optional.empty();
 2992: 
 2995:             return cachedArcaneRespawnAnchorEmptyMultiplier;
 2997:         int charges = Math.max(0, state.get(RespawnAnchorBlock.CHARGES));
 2999:             return cachedArcaneRespawnAnchorEmptyMultiplier;
 3001:         float scaled = cachedArcaneRespawnAnchorEmptyMultiplier + charges * cachedArcaneRespawnAnchorChargeStep;
 3002:         return MathHelper.clamp(scaled, 0f, cachedArcaneRespawnAnchorMaxMultiplier);
 3004: 
 3007:             return cachedArcaneBeaconBaseMultiplier;
 3009:         BlockEntity blockEntity = world.getBlockEntity(pos);
 3010:         int level = 0;
 3012:             level = Math.max(0, tryExtractBeaconLevel(blockEntity));
 3014:         float multiplier = cachedArcaneBeaconBaseMultiplier + cachedArcaneBeaconPerLevelMultiplier * level;
 3015:         return MathHelper.clamp(multiplier, 0f, cachedArcaneBeaconMaxMultiplier);
 3017: 
 3019:         int fromField = extractBeaconLevelFromField(blockEntity);
 3021:             return fromField;
 3023:         int fromBeaconGetter = extractBeaconLevelFromMethod(blockEntity, "getBeaconLevel");
 3025:             return fromBeaconGetter;
 3027:         return Math.max(0, extractBeaconLevelFromMethod(blockEntity, "getLevel"));
 3029: 
 3031:         Optional<Field> field = lookupArcaneField(blockEntity.getClass(), "level");
 3033:             return -1;
 3036:             Object value = field.get().get(blockEntity);
 3038:                 return Math.max(0, number.intValue());
 3042:         return -1;
 3044: 
 3046:         Optional<Method> method = lookupArcaneZeroArgMethod(blockEntity.getClass(), methodName);
 3048:             return -1;
 3051:             Object result = method.get().invoke(blockEntity);
 3053:                 return Math.max(0, number.intValue());
 3057:         return -1;
 3059: 
 3062:             return cachedArcaneCatalystInactiveMultiplier;
 3064:         BlockEntity blockEntity = world.getBlockEntity(pos);
 3066:             return cachedArcaneCatalystInactiveMultiplier;
 3068:         long lastBloomTick = extractSculkCatalystBloomTick(blockEntity);
 3070:             return cachedArcaneCatalystInactiveMultiplier;
 3072:         long now = world.getTime();
 3073:         long window = Math.max(1L, cachedArcaneCatalystRecentBloomTicks);
 3074:         long delta = Math.max(0L, now - lastBloomTick);
 3076:             return MathHelper.clamp(cachedArcaneCatalystActiveMultiplier, 0f, Math.max(cachedArcaneCatalystActiveMultiplier, cachedArcaneCatalystInactiveMultiplier));
 3079:             return cachedArcaneCatalystInactiveMultiplier;
 3081:         double progress = 1.0d - ((double) delta / (double) window);
 3082:         float blended = cachedArcaneCatalystInactiveMultiplier
 3083:             + (float) progress * (cachedArcaneCatalystActiveMultiplier - cachedArcaneCatalystInactiveMultiplier);
 3084:         float max = Math.max(cachedArcaneCatalystActiveMultiplier, cachedArcaneCatalystInactiveMultiplier);
 3085:         return MathHelper.clamp(blended, 0f, max);
 3087: 
 3090:             return Long.MIN_VALUE;
 3092:         Optional<Method> lastBloomTickMethod = lookupArcaneZeroArgMethod(blockEntity.getClass(), "getLastBloomTick");
 3095:                 Object result = lastBloomTickMethod.get().invoke(blockEntity);
 3097:                     return number.longValue();
 3102: 
 3103:         Optional<Method> lastBloomTimeMethod = lookupArcaneZeroArgMethod(blockEntity.getClass(), "getLastBloomTime");
 3106:                 Object result = lastBloomTimeMethod.get().invoke(blockEntity);
 3108:                     return number.longValue();
 3113: 
 3114:         Optional<Field> lastBloomTickField = lookupArcaneField(blockEntity.getClass(), "lastBloomTick");
 3117:                 Object value = lastBloomTickField.get().get(blockEntity);
 3119:                     return number.longValue();
 3124: 
 3125:         Optional<Field> lastBloomTimeField = lookupArcaneField(blockEntity.getClass(), "lastBloomTime");
 3128:                 Object value = lastBloomTimeField.get().get(blockEntity);
 3130:                     return number.longValue();
 3135:         return Long.MIN_VALUE;
 3137: 
 3139:         return state.isOf(Blocks.ENCHANTING_TABLE)
 3140:             || state.isOf(Blocks.AMETHYST_BLOCK)
 3141:             || state.isOf(Blocks.RESPAWN_ANCHOR)
 3142:             || state.isOf(Blocks.BEACON)
 3143:             || state.isOf(Blocks.BREWING_STAND)
 3144:             || state.isOf(Blocks.END_PORTAL_FRAME)
 3145:             || state.isOf(Blocks.SCULK_CATALYST);
 3147: 
 3150:             return true;
 3152:         RegistryEntry<Biome> biome = world.getBiome(pos);
 3154:             return true;
 3156:         return biome.matchesKey(BiomeKeys.LUSH_CAVES) || biome.matchesKey(BiomeKeys.DEEP_DARK);
 3158: 
 3159:     /**
 3160:      * Compute emotion-specific context modulation based on bond, danger, health, etc.
 3161:      * Replaces the old uniform multiplication with targeted adjustments.
 3162:      */
 3164:         float modulation = 0f;
 3165:         PetComponent.Emotion emotion = record.emotion;
 3166:         
 3167:         // Nature modifiers for context-aware scaling
 3168:         float resilienceMod = parent.getNatureResilienceMultiplier();
 3169: 
 3170:         // Bond strength effects (high bond amplifies attachment emotions)
 3171:         float bondStrength = parent.getBondStrength();
 3172:         float bondFactor = MathHelper.clamp(bondStrength / RELATIONSHIP_VARIANCE, 0f, 2f);
 3173:         // Validate bondFactor is in reasonable range
 3174:         bondFactor = MathHelper.clamp(bondFactor, 0.0f, 3.0f);
 3175: 
 3177:             case SAUDADE:
 3178:             case HIRAETH:
 3179:             case REGRET:
 3180:                 // High bond amplifies longing/regret
 3181:                 modulation += 0.3f * (bondFactor - 1.0f);
 3182:                 break;
 3183: 
 3184:             case UBUNTU:
 3185:             case QUERECIA:
 3186:             case PACK_SPIRIT:
 3187:                 // High bond amplifies connection emotions and pack unity
 3188:                 modulation += 0.25f * (bondFactor - 1.0f);
 3189:                 break;
 3190: 
 3191:             case RELIEF:
 3192:                 // Relief stronger when bond is high (you care more)
 3193:                 modulation += 0.2f * (bondFactor - 1.0f);
 3194:                 break;
 3195:                 
 3196:             case ECHOED_RESONANCE:
 3197:                 // Echoed Resonance strengthened by deep bonds forged through danger
 3198:                 modulation += 0.35f * (bondFactor - 1.0f);
 3199:                 break;
 3200:                 
 3201:             // All other emotions: no bond-based modulation
 3202:             default:
 3203:                 break;
 3205: 
 3206:         // Danger window effects
 3207:         float dangerRecency = record.dangerWindow; // Already calculated in refreshContextGuards
 3208:         float dangerBoost = MathHelper.clamp((dangerRecency - 1.0f), -0.5f, 0.8f);
 3209:         // Validate dangerBoost is in reasonable range
 3210:         dangerBoost = MathHelper.clamp(dangerBoost, -1.0f, 1.0f);
 3211: 
 3213:             case FOREBODING:
 3214:             case STARTLE:
 3215:             case ANGST:
 3216:                 // Danger amplifies fear emotions
 3217:                 modulation += 0.4f * Math.max(0f, dangerBoost);
 3218:                 break;
 3219: 
 3220:             case GUARDIAN_VIGIL:
 3221:             case PACK_SPIRIT:
 3222:                 // Danger increases Guardian Vigil resolve and pack unity
 3223:                 modulation += 0.35f * Math.max(0f, dangerBoost);
 3224:                 break;
 3225:                 
 3226:             case ECHOED_RESONANCE:
 3227:                 // Echoed Resonance is born from danger - strongly amplified
 3228:                 modulation += 0.5f * Math.max(0f, dangerBoost);
 3229:                 break;
 3230: 
 3231:             case LAGOM:
 3232:             case CONTENT:
 3233:             case QUERECIA:
 3234:                 // Danger suppresses calm/peaceful emotions
 3235:                 modulation -= 0.3f * Math.max(0f, dangerBoost);
 3236:                 break;
 3237:                 
 3238:             case ARCANE_OVERFLOW:
 3239:                 // Arcane Overflow unaffected by mundane danger
 3240:                 break;
 3241:                 
 3242:             // All other emotions: no danger-based modulation
 3243:             default:
 3244:                 break;
 3246: 
 3247:         // Health effects - nonlinear scaling for dramatic storytelling
 3248:         float healthRatio = parent.getPet().getHealth() / parent.getPet().getMaxHealth();
 3249:         healthRatio = MathHelper.clamp(healthRatio, 0.0f, 1.0f);
 3250:         
 3251:         // Critical health (< 40%): significant emotional impact
 3253:             float healthPenalty = (0.4f - healthRatio) / 0.4f; // 0 at 40%, 1 at 0% health
 3254:             healthPenalty = MathHelper.clamp(healthPenalty, 0.0f, 1.0f);
 3255:             
 3256:             // Scale penalty by current emotional level for dramatic effect
 3257:             int currentLevel = getMoodLevel();
 3258:             float levelScale = 1.0f + (currentLevel * 0.15f); // Level 3 = 1.45x effect
 3259: 
 3261:                 case ANGST:
 3262:                 case FOREBODING:
 3263:                     // Low health amplifies distress emotions
 3264:                     modulation += 0.3f * healthPenalty * levelScale;
 3265:                     break;
 3266: 
 3267:                 case CHEERFUL:
 3268:                 case KEFI:
 3269:                 case PLAYFULNESS:
 3270:                     // Low health suppresses energetic emotions
 3271:                     modulation -= 0.4f * healthPenalty;
 3272:                     break;
 3273:                     
 3274:                 case ARCANE_OVERFLOW:
 3275:                     // Arcane overflow: mystical energy persists despite physical state
 3276:                     // Slight boost when near death (dramatic magical surge)
 3278:                         modulation += 0.15f * healthPenalty;
 3280:                     break;
 3281:                     
 3282:                 case ECHOED_RESONANCE:
 3283:                 case PACK_SPIRIT:
 3284:                     // Ultra-rare bond states: strengthen when wounded together
 3285:                     modulation += 0.2f * healthPenalty;
 3286:                     break;
 3287:                     
 3288:                 case SISU:
 3289:                 case GAMAN:
 3290:                 case STOIC:
 3291:                     // Endurance emotions RISE when injured (defiant resilience)
 3292:                     modulation += 0.35f * healthPenalty * resilienceMod;
 3293:                     break;
 3294:                     
 3295:                 default:
 3296:                     // Other emotions moderately affected by low health
 3297:                     break;
 3300: 
 3301:         return modulation;
 3303: 
 3304:     private float getProfileScale(PetComponent.Emotion emotion,
 3305:                                   float majorScale,
 3306:                                   float minorScale,
 3307:                                   float quirkScale,
 3308:                                   float min,
 3310:         // Null safety: handle missing or empty profiles gracefully
 3312:             return 1f;
 3314:         
 3315:         // Validate scale parameters to prevent extreme modulation
 3316:         majorScale = MathHelper.clamp(majorScale, -1f, 2f);
 3317:         minorScale = MathHelper.clamp(minorScale, -1f, 2f);
 3318:         quirkScale = MathHelper.clamp(quirkScale, -1f, 2f);
 3319:         
 3320:         float factor = 1f;
 3322:             factor += natureEmotionProfile.majorStrength() * majorScale;
 3324:             factor += natureEmotionProfile.minorStrength() * minorScale;
 3326:             factor += natureEmotionProfile.quirkStrength() * quirkScale;
 3328:         
 3329:         // Ensure final factor stays within specified bounds
 3330:         factor = MathHelper.clamp(factor, min, max);
 3331:         // Final safety clamp to prevent any extreme values
 3332:         return MathHelper.clamp(factor, 0.0f, 1.40f); // Phase 2 tuning
 3334: 
 3336:         ensureConfigCache();
 3337:         Map<PetComponent.Mood, Float> cached = resolvedWeightCache.get(emotion);
 3339:             return cached;
 3341:         EnumMap<PetComponent.Mood, Float> resolved = resolveEmotionToMoodWeights(cachedMoodsSection, emotion);
 3342:         Map<PetComponent.Mood, Float> immutable = Collections.unmodifiableMap(resolved);
 3343:         resolvedWeightCache.put(emotion, immutable);
 3344:         return immutable;
 3346: 
 3348:         MoodEngineConfig moodConfig = MoodEngineConfig.get();
 3349:         int generation = moodConfig.getGeneration();
 3351:             return;
 3353:         cachedConfigGeneration = generation;
 3354:         cachedMoodsSection = moodConfig.getMoodsSection();
 3355:         resolvedWeightCache.clear();
 3356:         invalidateArcaneAmbientCachesIfNeeded(generation);
 3357:         cachedWeightSection = getObject(cachedMoodsSection, "weight");
 3358:         cachedOpponentSection = getObject(cachedMoodsSection, "opponents");
 3359:         cachedAnimationSection = getObject(cachedMoodsSection, "animation");
 3360:         cachedMomentum = RegistryJsonHelper.getDouble(cachedMoodsSection, "momentum", 0.35d);
 3361:         cachedSwitchMargin = RegistryJsonHelper.getDouble(cachedMoodsSection, "switchMargin", 0.05d);
 3362:         cachedHysteresisTicks = RegistryJsonHelper.getInt(cachedMoodsSection, "hysteresisTicks", 60);
 3363:         cachedEpsilon = RegistryJsonHelper.getFloat(cachedMoodsSection, "epsilon", 0.05f);
 3364:         cachedLevelThresholds = parseLevelThresholds(cachedMoodsSection);
 3365:         cachedBaseAnimationUpdateInterval = RegistryJsonHelper.getInt(cachedAnimationSection, "baseAnimationUpdateInterval", 16);
 3366:         cachedAnimationSpeedMultiplier = RegistryJsonHelper.getDouble(cachedAnimationSection, "animationSpeedMultiplier", 0.15d);
 3367:         cachedMinAnimationInterval = RegistryJsonHelper.getInt(cachedAnimationSection, "minAnimationInterval", 4);
 3368:         cachedMaxAnimationInterval = RegistryJsonHelper.getInt(cachedAnimationSection, "maxAnimationInterval", 40);
 3369: 
 3370:         JsonObject guardianSection = getObject(cachedMoodsSection, "guardianVigil");
 3371:         cachedOwnerDamageWindow = Math.max(20, RegistryJsonHelper.getInt(guardianSection, "recentDamageWindow", 160));
 3372:         cachedOwnerDangerGraceTicks = Math.max(cachedOwnerDamageWindow,
 3373:             RegistryJsonHelper.getLong(guardianSection, "dangerGraceTicks", 200L));
 3374:         cachedOwnerLowHealthGraceTicks = Math.max(40L,
 3375:             RegistryJsonHelper.getLong(guardianSection, "lowHealthGraceTicks", 260L));
 3376:         cachedOwnerLowHealthThreshold = MathHelper.clamp(
 3377:             RegistryJsonHelper.getFloat(guardianSection, "lowHealthThreshold", 0.45f), 0.05f, 0.95f);
 3378:         cachedOwnerCriticalHealthThreshold = MathHelper.clamp(
 3379:             RegistryJsonHelper.getFloat(guardianSection, "criticalHealthThreshold", 0.25f), 0.0f,
 3380:             cachedOwnerLowHealthThreshold);
 3381:         cachedOwnerStatusHazardGraceTicks = Math.max(40L,
 3382:             RegistryJsonHelper.getLong(guardianSection, "statusHazardGraceTicks", 180L));
 3383:         cachedOwnerStatusHazardThreshold = MathHelper.clamp(
 3384:             RegistryJsonHelper.getFloat(guardianSection, "statusHazardSeverityThreshold", 0.25f), 0.05f, 1.0f);
 3385: 
 3386:         JsonObject packSpiritSection = getObject(cachedMoodsSection, "packSpirit");
 3387:         cachedPackSpiritRadius = Math.max(2.0d, RegistryJsonHelper.getDouble(packSpiritSection, "radius", 12.0d));
 3388:         cachedPackSpiritMinPackmates = Math.max(1,
 3389:             RegistryJsonHelper.getInt(packSpiritSection, "minPackmates", 1));
 3390:         cachedPackSpiritGraceTicks = Math.max(20L,
 3391:             RegistryJsonHelper.getLong(packSpiritSection, "lingerTicks", 140L));
 3392:         cachedPackSpiritBondBonus = MathHelper.clamp(
 3393:             RegistryJsonHelper.getFloat(packSpiritSection, "bondBonus", 0.3f), 0f, 1f);
 3394:         cachedPackSpiritBaseContribution = MathHelper.clamp(
 3395:             RegistryJsonHelper.getFloat(packSpiritSection, "baseContribution", cachedPackSpiritBaseContribution), 0f, 2f);
 3396:         JsonObject engagementSection = getObject(packSpiritSection, "engagement");
 3397:         cachedPackSpiritRoleWeights.clear();
 3399:             cachedPackSpiritRoleWeights.put(archetype, 1.0f);
 3402:             cachedPackSpiritBaseContribution = MathHelper.clamp(
 3403:                 RegistryJsonHelper.getFloat(engagementSection, "baseContribution", cachedPackSpiritBaseContribution), 0f, 2f);
 3404:             cachedPackSpiritClosenessWeight = MathHelper.clamp(
 3405:                 RegistryJsonHelper.getFloat(engagementSection, "closenessWeight", cachedPackSpiritClosenessWeight), 0f, 3f);
 3406:             cachedPackSpiritCombatBonus = MathHelper.clamp(
 3407:                 RegistryJsonHelper.getFloat(engagementSection, "combatBonus", cachedPackSpiritCombatBonus), 0f, 1f);
 3408:             cachedPackSpiritProtectiveWeight = MathHelper.clamp(
 3409:                 RegistryJsonHelper.getFloat(engagementSection, "protectiveMoodWeight", cachedPackSpiritProtectiveWeight), 0f, 1.5f);
 3410:             cachedPackSpiritFocusedWeight = MathHelper.clamp(
 3411:                 RegistryJsonHelper.getFloat(engagementSection, "focusedMoodWeight", cachedPackSpiritFocusedWeight), 0f, 1.0f);
 3412:             cachedPackSpiritPlayfulWeight = MathHelper.clamp(
 3413:                 RegistryJsonHelper.getFloat(engagementSection, "playfulMoodWeight", cachedPackSpiritPlayfulWeight), 0f, 1.0f);
 3414:             cachedPackSpiritDiversityBonus = MathHelper.clamp(
 3415:                 RegistryJsonHelper.getFloat(engagementSection, "diversityBonus", cachedPackSpiritDiversityBonus), 0f, 1.0f);
 3416:             cachedPackSpiritEngagementMax = MathHelper.clamp(
 3417:                 RegistryJsonHelper.getFloat(engagementSection, "maxContribution", cachedPackSpiritEngagementMax), 0.1f, 3.0f);
 3418:             JsonObject roleWeights = getObject(engagementSection, "roleWeights");
 3421:                     JsonElement element = roleWeights.get(archetype.name());
 3423:                         cachedPackSpiritRoleWeights.put(archetype,
 3424:                             MathHelper.clamp(element.getAsFloat(), 0f, 3.0f));
 3429: 
 3430:         JsonObject arcaneSection = getObject(cachedMoodsSection, "arcaneOverflow");
 3431:         cachedArcaneOverflowLingerTicks = Math.max(40L,
 3432:             RegistryJsonHelper.getLong(arcaneSection, "lingerTicks", 220L));
 3433:         cachedArcaneOverflowStreakGraceTicks = Math.max(40L,
 3434:             RegistryJsonHelper.getLong(arcaneSection, "streakGraceTicks", 200L));
 3435:         cachedArcaneOverflowStatusGraceTicks = Math.max(40L,
 3436:             RegistryJsonHelper.getLong(arcaneSection, "statusGraceTicks", 160L));
 3437:         cachedArcaneOverflowAmbientScanRadius = Math.max(1,
 3438:             RegistryJsonHelper.getInt(arcaneSection, "ambientScanRadius", 4));
 3439:         cachedArcaneOverflowMinimumEnergy = MathHelper.clamp(
 3440:             RegistryJsonHelper.getFloat(arcaneSection, "minimumEnergy", 0.25f), 0.05f, 1.0f);
 3441:         cachedArcaneAmbientStructureBaseWeight = MathHelper.clamp(
 3442:             RegistryJsonHelper.getFloat(arcaneSection, "structureBaseWeight", 0.35f), 0f, 1.5f);
 3443:         cachedArcaneAmbientStructureMaxEnergy = MathHelper.clamp(
 3444:             RegistryJsonHelper.getFloat(arcaneSection, "structureMaxEnergy", 0.85f), 0f, 2.0f);
 3445:         cachedArcaneAmbientDistanceExponent = Math.max(0.25f,
 3446:             RegistryJsonHelper.getFloat(arcaneSection, "structureDistanceExponent", 1.0f));
 3447:         cachedArcaneAmbientMysticBonus = MathHelper.clamp(
 3448:             RegistryJsonHelper.getFloat(arcaneSection, "mysticEnvironmentBonus", 0.2f), 0f, 1.0f);
 3449:         cachedArcaneAmbientStructureWeights = new HashMap<>();
 3450:         JsonObject arcaneWeights = getObject(arcaneSection, "structureWeights");
 3453:                 JsonElement value = entry.getValue();
 3455:                     continue;
 3457:                 Identifier id = Identifier.tryParse(entry.getKey());
 3459:                     continue;
 3462:                     cachedArcaneAmbientStructureWeights.put(id,
 3463:                         MathHelper.clamp(value.getAsFloat(), 0f, 2.0f));
 3467:         JsonObject stateModifiers = getObject(arcaneSection, "structureState");
 3468:         JsonObject respawnConfig = getObject(stateModifiers, "respawnAnchor");
 3469:         cachedArcaneRespawnAnchorEmptyMultiplier = MathHelper.clamp(
 3470:             RegistryJsonHelper.getFloat(respawnConfig, "emptyMultiplier", cachedArcaneRespawnAnchorEmptyMultiplier), 0f, 2.0f);
 3471:         cachedArcaneRespawnAnchorChargeStep = MathHelper.clamp(
 3472:             RegistryJsonHelper.getFloat(respawnConfig, "chargeStep", cachedArcaneRespawnAnchorChargeStep), 0f, 2.0f);
 3473:         cachedArcaneRespawnAnchorMaxMultiplier = MathHelper.clamp(
 3474:             RegistryJsonHelper.getFloat(respawnConfig, "maxMultiplier", cachedArcaneRespawnAnchorMaxMultiplier), 0.1f, 4.0f);
 3475:         JsonObject beaconConfig = getObject(stateModifiers, "beacon");
 3476:         cachedArcaneBeaconBaseMultiplier = MathHelper.clamp(
 3477:             RegistryJsonHelper.getFloat(beaconConfig, "baseMultiplier", cachedArcaneBeaconBaseMultiplier), 0f, 3.0f);
 3478:         cachedArcaneBeaconPerLevelMultiplier = MathHelper.clamp(
 3479:             RegistryJsonHelper.getFloat(beaconConfig, "perLevel", cachedArcaneBeaconPerLevelMultiplier), 0f, 2.0f);
 3480:         cachedArcaneBeaconMaxMultiplier = MathHelper.clamp(
 3481:             RegistryJsonHelper.getFloat(beaconConfig, "maxMultiplier", cachedArcaneBeaconMaxMultiplier), 0.1f, 6.0f);
 3482:         JsonObject sculkConfig = getObject(stateModifiers, "sculkCatalyst");
 3483:         cachedArcaneCatalystRecentBloomTicks = Math.max(20L,
 3484:             RegistryJsonHelper.getLong(sculkConfig, "recentBloomTicks", cachedArcaneCatalystRecentBloomTicks));
 3485:         cachedArcaneCatalystActiveMultiplier = MathHelper.clamp(
 3486:             RegistryJsonHelper.getFloat(sculkConfig, "activeMultiplier", cachedArcaneCatalystActiveMultiplier), 0f, 4.0f);
 3487:         cachedArcaneCatalystInactiveMultiplier = MathHelper.clamp(
 3488:             RegistryJsonHelper.getFloat(sculkConfig, "inactiveMultiplier", cachedArcaneCatalystInactiveMultiplier), 0f, 4.0f);
 3489:         JsonObject gearSection = getObject(arcaneSection, "gearWeights");
 3490:         cachedArcaneGearBaseWeight = MathHelper.clamp(
 3491:             RegistryJsonHelper.getFloat(gearSection, "base", cachedArcaneGearBaseWeight), 0f, 1f);
 3492:         cachedArcaneGearLevelWeight = MathHelper.clamp(
 3493:             RegistryJsonHelper.getFloat(gearSection, "perLevel", cachedArcaneGearLevelWeight), 0f, 1f);
 3494:         cachedArcaneGearMaxContribution = MathHelper.clamp(
 3495:             RegistryJsonHelper.getFloat(gearSection, "maxContribution", cachedArcaneGearMaxContribution), 0.1f, 4f);
 3496:         cachedArcaneGearOwnerMultiplier = MathHelper.clamp(
 3497:             RegistryJsonHelper.getFloat(gearSection, "ownerMultiplier", cachedArcaneGearOwnerMultiplier), 0f, 3.0f);
 3498:         cachedArcaneGearPetMultiplier = MathHelper.clamp(
 3499:             RegistryJsonHelper.getFloat(gearSection, "petMultiplier", cachedArcaneGearPetMultiplier), 0f, 3.0f);
 3500:         cachedArcaneScanCooldownTicks = Math.max(20L,
 3501:             RegistryJsonHelper.getLong(arcaneSection, "scanCooldownTicks", 80L));
 3502:         cachedArcaneScanMovementThreshold = Math.max(0.0d,
 3503:             RegistryJsonHelper.getDouble(arcaneSection, "scanMovementThreshold", 3.0d));
 3504:         cachedArcaneScanMovementThresholdSquared = cachedArcaneScanMovementThreshold
 3505:             * cachedArcaneScanMovementThreshold;
 3506:         JsonObject statusSection = getObject(arcaneSection, "statusWeights");
 3507:         cachedArcaneStatusBaseWeight = MathHelper.clamp(
 3508:             RegistryJsonHelper.getFloat(statusSection, "base", cachedArcaneStatusBaseWeight), 0f, 1f);
 3509:         cachedArcaneStatusAmplifierWeight = MathHelper.clamp(
 3510:             RegistryJsonHelper.getFloat(statusSection, "amplifier", cachedArcaneStatusAmplifierWeight), 0f, 1f);
 3511:         cachedArcaneStatusDurationReference = Math.max(20,
 3512:             RegistryJsonHelper.getInt(statusSection, "durationReferenceTicks", cachedArcaneStatusDurationReference));
 3513:         cachedArcaneStatusDurationWeight = MathHelper.clamp(
 3514:             RegistryJsonHelper.getFloat(statusSection, "durationWeight", cachedArcaneStatusDurationWeight), 0f, 1f);
 3515:         cachedArcaneStatusDurationCap = MathHelper.clamp(
 3516:             RegistryJsonHelper.getFloat(statusSection, "durationCap", cachedArcaneStatusDurationCap), 0.25f, 10f);
 3517:         cachedArcaneStatusMaxContribution = MathHelper.clamp(
 3518:             RegistryJsonHelper.getFloat(statusSection, "maxContribution", cachedArcaneStatusMaxContribution), 0.1f, 2.0f);
 3519:         cachedArcaneStatusOwnerMultiplier = MathHelper.clamp(
 3520:             RegistryJsonHelper.getFloat(statusSection, "ownerMultiplier", cachedArcaneStatusOwnerMultiplier), 0f, 3.0f);
 3521:         cachedArcaneStatusPetMultiplier = MathHelper.clamp(
 3522:             RegistryJsonHelper.getFloat(statusSection, "petMultiplier", cachedArcaneStatusPetMultiplier), 0f, 3.0f);
 3523: 
 3524:         JsonObject lonelinessSection = getObject(cachedMoodsSection, "loneliness");
 3525:         cachedLonelyComfortRadius = Math.max(1.0d,
 3526:             RegistryJsonHelper.getDouble(lonelinessSection, "comfortRadius", 8.0d));
 3527:         cachedLonelyDistanceThreshold = Math.max(cachedLonelyComfortRadius,
 3528:             RegistryJsonHelper.getDouble(lonelinessSection, "distanceThreshold", 24.0d));
 3529:         cachedLonelySaudadeGraceTicks = Math.max(40L,
 3530:             RegistryJsonHelper.getLong(lonelinessSection, "saudadeGraceTicks", 400L));
 3531:         cachedLonelyHiraethGraceTicks = Math.max(cachedLonelySaudadeGraceTicks,
 3532:             RegistryJsonHelper.getLong(lonelinessSection, "hiraethGraceTicks", 900L));
 3533:         cachedLonelyOfflineGraceTicks = Math.max(40L,
 3534:             RegistryJsonHelper.getLong(lonelinessSection, "offlineGraceTicks", 200L));
 3535:         cachedLonelyOfflineHiraethGraceTicks = Math.max(cachedLonelyOfflineGraceTicks,
 3536:             RegistryJsonHelper.getLong(lonelinessSection, "offlineHiraethGraceTicks", 600L));
 3537:         cachedLonelyComfortRadiusSquared = cachedLonelyComfortRadius * cachedLonelyComfortRadius;
 3538:         cachedLonelyDistanceThresholdSquared = cachedLonelyDistanceThreshold * cachedLonelyDistanceThreshold;
 3539:         cachedLonelySocialGraceTicks = Math.max(20L,
 3540:             RegistryJsonHelper.getLong(lonelinessSection, "socialGraceTicks", cachedLonelySocialGraceTicks));
 3541:         cachedLonelyPackGraceTicks = Math.max(20L,
 3542:             RegistryJsonHelper.getLong(lonelinessSection, "packGraceTicks", cachedLonelyPackGraceTicks));
 3543:         cachedLonelyPackStrengthThreshold = MathHelper.clamp(
 3544:             RegistryJsonHelper.getFloat(lonelinessSection, "packStrengthThreshold", cachedLonelyPackStrengthThreshold), 0f, 1f);
 3545:         cachedLonelyPackRadius = Math.max(1.0d,
 3546:             RegistryJsonHelper.getDouble(lonelinessSection, "packRadius",
 3547:                 Math.max(cachedLonelyPackRadius, cachedLonelyDistanceThreshold)));
 3548:         cachedLonelyPackRadiusSquared = cachedLonelyPackRadius * cachedLonelyPackRadius;
 3549: 
 3550:         JsonObject positiveSection = getObject(cachedMoodsSection, "positiveCues");
 3551:         cachedPositivePetGraceTicks = Math.max(20L,
 3552:             RegistryJsonHelper.getLong(positiveSection, "pettingGraceTicks", 200L));
 3553:         cachedPositiveCrouchGraceTicks = Math.max(20L,
 3554:             RegistryJsonHelper.getLong(positiveSection, "crouchGraceTicks", 160L));
 3555:         cachedPositiveSocialGraceTicks = Math.max(20L,
 3556:             RegistryJsonHelper.getLong(positiveSection, "socialBufferGraceTicks", 200L));
 3557:         cachedPositivePlayGraceTicks = Math.max(20L,
 3558:             RegistryJsonHelper.getLong(positiveSection, "playGraceTicks", 240L));
 3559:         cachedPositiveFeedGraceTicks = Math.max(20L,
 3560:             RegistryJsonHelper.getLong(positiveSection, "feedingGraceTicks", 260L));
 3561:         cachedPositiveGiftGraceTicks = Math.max(20L,
 3562:             RegistryJsonHelper.getLong(positiveSection, "giftGraceTicks", 360L));
 3563: 
 3564:         loadEmotionDecayMultipliers();
 3565:         loadEmotionValence();
 3566:         loadMoodThresholds();
 3567:         loadAdvancedSettings();
 3568:         rebuildOpponentPairs();
 3570: 
 3573:             cachedArcaneAmbientConfigGeneration = generation;
 3574:             StateManager.invalidateArcaneAmbientCaches();
 3577: 
 3582:         JsonElement array = section.get("levelThresholds");
 3586:         List<Float> values = new ArrayList<>();
 3589:                 values.add(el.getAsFloat());
 3595:         float[] out = new float[values.size()];
 3597:             out[i] = values.get(i);
 3599:         return out;
 3601:     
 3603:         cachedEmotionDecayMultipliers.clear();
 3604:         JsonObject multipliers = getObject(cachedMoodsSection, "emotionDecayMultipliers");
 3607:                 JsonElement el = multipliers.get(key);
 3609:                     cachedEmotionDecayMultipliers.put(key, el.getAsFloat());
 3614:     
 3616:         cachedNegativeEmotions.clear();
 3617:         cachedPositiveEmotions.clear();
 3618:         JsonObject valence = getObject(cachedMoodsSection, "emotionValence");
 3620:             JsonElement negative = valence.get("negative");
 3624:                         cachedNegativeEmotions.add(el.getAsString());
 3628:             JsonElement positive = valence.get("positive");
 3632:                         cachedPositiveEmotions.add(el.getAsString());
 3638:     
 3640:         perMoodThresholds.clear();
 3641:         JsonObject moodThresholds = getObject(cachedMoodsSection, "moodThresholds");
 3643:             String key = mood.name().toLowerCase();
 3645:                 JsonElement el = moodThresholds.get(key);
 3647:                     float[] thresholds = parseThresholdsArray(el.getAsJsonArray());
 3649:                         perMoodThresholds.put(mood, thresholds);
 3650:                         continue;
 3654:             perMoodThresholds.put(mood, cachedLevelThresholds);
 3657:     
 3659:         List<Float> values = new ArrayList<>();
 3662:                 values.add(el.getAsFloat());
 3665:         if (values.isEmpty()) return null;
 3666:         float[] out = new float[values.size()];
 3668:             out[i] = values.get(i);
 3670:         return out;
 3672:     
 3674:         JsonObject root = MoodEngineConfig.get().getRoot();
 3675:         JsonObject advanced = getObject(root, "advanced");
 3676:         if (advanced == null) return;
 3677:         
 3678:         JsonObject decay = getObject(advanced, "decay");
 3680:             cachedHabituationBase = RegistryJsonHelper.getFloat(decay, "habituation_base", HABITUATION_BASE);
 3681:             cachedHalfLifeMultiplier = RegistryJsonHelper.getFloat(decay, "half_life_multiplier", HALF_LIFE_MULTIPLIER);
 3682:             cachedMinHalfLife = RegistryJsonHelper.getFloat(decay, "min_half_life", MIN_HALF_LIFE);
 3683:             cachedMaxHalfLife = RegistryJsonHelper.getFloat(decay, "max_half_life", MAX_HALF_LIFE);
 3684:             cachedNegativePersistence = RegistryJsonHelper.getFloat(decay, "negative_persistence", 2.0f);
 3685:             cachedConditionPresentMultiplier = RegistryJsonHelper.getFloat(decay, "condition_present_multiplier", 3.5f);
 3686:             cachedHomeostasisRecoveryHalf = RegistryJsonHelper.getFloat(decay, "homeostasis_recovery_half", HOMEOSTASIS_RECOVERY_HALF);
 3688:         
 3689:         JsonObject habituation = getObject(advanced, "habituation");
 3691:             cachedCadenceAlpha = RegistryJsonHelper.getFloat(habituation, "cadence_alpha", CADENCE_ALPHA);
 3692:             cachedVolatilityAlpha = RegistryJsonHelper.getFloat(habituation, "volatility_alpha", VOLATILITY_ALPHA);
 3693:             cachedPeakAlpha = RegistryJsonHelper.getFloat(habituation, "peak_alpha", PEAK_ALPHA);
 3695:         
 3696:         JsonObject opponent = getObject(advanced, "opponent");
 3698:             cachedOpponentTransferMax = RegistryJsonHelper.getFloat(opponent, "transfer_max", OPPONENT_TRANSFER_MAX);
 3699:             cachedReboundGain = RegistryJsonHelper.getFloat(opponent, "rebound_gain", REBOUND_GAIN);
 3701:         
 3702:         JsonObject context = getObject(advanced, "context");
 3704:             cachedRelationshipVariance = RegistryJsonHelper.getFloat(context, "relationship_variance", RELATIONSHIP_VARIANCE);
 3705:             cachedCarePulseHalfLife = RegistryJsonHelper.getFloat(context, "care_pulse_half_life", CARE_PULSE_HALF_LIFE);
 3706:             cachedDangerHalfLife = RegistryJsonHelper.getFloat(context, "danger_half_life", DANGER_HALF_LIFE);
 3709: 
 3710:     static EnumMap<PetComponent.Mood, Float> resolveEmotionToMoodWeights(@Nullable JsonObject moodsSection,
 3712:         EnumMap<PetComponent.Mood, Float> weights = copyDefaultEmotionToMoodWeights(emotion);
 3713:         JsonObject section = getObject(moodsSection, "emotionToMoodWeights");
 3715:             return weights;
 3717:         JsonObject emotionObj = getObject(section, emotion.name().toLowerCase());
 3719:             return weights;
 3721:         boolean sawOverride = false;
 3723:             float override = RegistryJsonHelper.getFloat(emotionObj, mood.name().toLowerCase(), Float.NaN);
 3725:                 // Validate override values are in reasonable range
 3726:                 override = MathHelper.clamp(override, 0.0f, 10.0f);
 3727:                 weights.put(mood, Math.max(0f, override));
 3728:                 sawOverride = true;
 3732:             return weights;
 3734:         float total = 0f;
 3736:             total += Math.max(0f, value);
 3739:             return copyDefaultEmotionToMoodWeights(emotion);
 3742:             entry.setValue(Math.max(0f, entry.getValue()) / total);
 3744:         return weights;
 3746: 
 3748:         return copyDefaultEmotionToMoodWeights(emotion);
 3750: 
 3752:         EnumMap<PetComponent.Mood, Float> defaults = DEFAULT_EMOTION_TO_MOOD.get(emotion);
 3754:             EnumMap<PetComponent.Mood, Float> uniform = new EnumMap<>(PetComponent.Mood.class);
 3755:             float base = 1f / PetComponent.Mood.values().length;
 3757:                 uniform.put(mood, base);
 3759:             return uniform;
 3761:         return new EnumMap<>(defaults);
 3763: 
 3765:         EnumMap<PetComponent.Emotion, EnumMap<PetComponent.Mood, Float>> table =
 3766:                 new EnumMap<>(PetComponent.Emotion.class);
 3767: 
 3768:         table.put(PetComponent.Emotion.CHEERFUL, weights(
 3769:                 Map.entry(PetComponent.Mood.HAPPY, 0.62f),
 3770:                 Map.entry(PetComponent.Mood.PLAYFUL, 0.23f),
 3771:                 Map.entry(PetComponent.Mood.CURIOUS, 0.15f)));
 3772:         table.put(PetComponent.Emotion.QUERECIA, weights(
 3773:                 Map.entry(PetComponent.Mood.HAPPY, 0.35f),
 3774:                 Map.entry(PetComponent.Mood.BONDED, 0.4f),
 3775:                 Map.entry(PetComponent.Mood.CALM, 0.25f)));
 3776:         table.put(PetComponent.Emotion.UBUNTU, weights(
 3777:                 Map.entry(PetComponent.Mood.BONDED, 0.6f),
 3778:                 Map.entry(PetComponent.Mood.HAPPY, 0.2f),
 3779:                 Map.entry(PetComponent.Mood.PROTECTIVE, 0.2f)));
 3780:         table.put(PetComponent.Emotion.KEFI, weights(
 3781:                 Map.entry(PetComponent.Mood.PLAYFUL, 0.45f),
 3782:                 Map.entry(PetComponent.Mood.PASSIONATE, 0.30f),
 3783:                 Map.entry(PetComponent.Mood.HAPPY, 0.25f)));
 3784:         table.put(PetComponent.Emotion.ANGST, weights(
 3785:                 Map.entry(PetComponent.Mood.RESTLESS, 0.35f),
 3786:                 Map.entry(PetComponent.Mood.AFRAID, 0.35f),
 3787:                 Map.entry(PetComponent.Mood.SAUDADE, 0.3f)));
 3788:         table.put(PetComponent.Emotion.FOREBODING, weights(
 3789:                 Map.entry(PetComponent.Mood.AFRAID, 0.55f),
 3790:                 Map.entry(PetComponent.Mood.RESTLESS, 0.25f),
 3791:                 Map.entry(PetComponent.Mood.PROTECTIVE, 0.20f)));
 3792:         table.put(PetComponent.Emotion.GUARDIAN_VIGIL, weights(
 3793:                 Map.entry(PetComponent.Mood.PROTECTIVE, 0.60f),
 3794:                 Map.entry(PetComponent.Mood.BONDED, 0.25f),
 3795:                 Map.entry(PetComponent.Mood.FOCUSED, 0.15f)));
 3796:         table.put(PetComponent.Emotion.FRUSTRATION, weights(
 3797:                 Map.entry(PetComponent.Mood.ANGRY, 0.5f),
 3798:                 Map.entry(PetComponent.Mood.RESTLESS, 0.3f),
 3799:                 Map.entry(PetComponent.Mood.PASSIONATE, 0.2f)));
 3800:         table.put(PetComponent.Emotion.STARTLE, weights(
 3801:                 Map.entry(PetComponent.Mood.AFRAID, 0.6f),
 3802:                 Map.entry(PetComponent.Mood.RESTLESS, 0.3f),
 3803:                 Map.entry(PetComponent.Mood.ANGRY, 0.1f)));
 3804:         table.put(PetComponent.Emotion.DISGUST, weights(
 3805:                 Map.entry(PetComponent.Mood.ANGRY, 0.5f),
 3806:                 Map.entry(PetComponent.Mood.AFRAID, 0.3f),
 3807:                 Map.entry(PetComponent.Mood.RESTLESS, 0.2f)));
 3808:         table.put(PetComponent.Emotion.REGRET, weights(
 3809:                 Map.entry(PetComponent.Mood.SAUDADE, 0.55f),
 3810:                 Map.entry(PetComponent.Mood.CALM, 0.20f),
 3811:                 Map.entry(PetComponent.Mood.RESTLESS, 0.25f)));
 3812:         table.put(PetComponent.Emotion.MONO_NO_AWARE, weights(
 3813:                 Map.entry(PetComponent.Mood.YUGEN, 0.5f),
 3814:                 Map.entry(PetComponent.Mood.SAUDADE, 0.3f),
 3815:                 Map.entry(PetComponent.Mood.CALM, 0.2f)));
 3816:         table.put(PetComponent.Emotion.FERNWEH, weights(
 3817:                 Map.entry(PetComponent.Mood.SAUDADE, 0.5f),
 3818:                 Map.entry(PetComponent.Mood.RESTLESS, 0.3f),
 3819:                 Map.entry(PetComponent.Mood.CURIOUS, 0.2f)));
 3820:         table.put(PetComponent.Emotion.SOBREMESA, weights(
 3821:                 Map.entry(PetComponent.Mood.BONDED, 0.50f),
 3822:                 Map.entry(PetComponent.Mood.CALM, 0.30f),
 3823:                 Map.entry(PetComponent.Mood.HAPPY, 0.20f)));
 3824:         table.put(PetComponent.Emotion.HANYAUKU, weights(
 3825:                 Map.entry(PetComponent.Mood.PLAYFUL, 0.5f),
 3826:                 Map.entry(PetComponent.Mood.HAPPY, 0.3f),
 3827:                 Map.entry(PetComponent.Mood.RESTLESS, 0.2f)));
 3828:         table.put(PetComponent.Emotion.WABI_SABI, weights(
 3829:                 Map.entry(PetComponent.Mood.CALM, 0.4f),
 3830:                 Map.entry(PetComponent.Mood.YUGEN, 0.35f),
 3831:                 Map.entry(PetComponent.Mood.SAUDADE, 0.25f)));
 3832:         table.put(PetComponent.Emotion.LAGOM, weights(
 3833:                 Map.entry(PetComponent.Mood.CALM, 0.50f),
 3834:                 Map.entry(PetComponent.Mood.BONDED, 0.25f),
 3835:                 Map.entry(PetComponent.Mood.HAPPY, 0.25f)));
 3836:         table.put(PetComponent.Emotion.ENNUI, weights(
 3837:                 Map.entry(PetComponent.Mood.RESTLESS, 0.50f),
 3838:                 Map.entry(PetComponent.Mood.SAUDADE, 0.30f),
 3839:                 Map.entry(PetComponent.Mood.CALM, 0.20f)));
 3840:         table.put(PetComponent.Emotion.YUGEN, weights(
 3841:                 Map.entry(PetComponent.Mood.YUGEN, 0.35f),
 3842:                 Map.entry(PetComponent.Mood.CALM, 0.40f),
 3843:                 Map.entry(PetComponent.Mood.SAUDADE, 0.25f)));
 3844:         table.put(PetComponent.Emotion.SAUDADE, weights(
 3845:                 Map.entry(PetComponent.Mood.SAUDADE, 0.7f),
 3846:                 Map.entry(PetComponent.Mood.YUGEN, 0.15f),
 3847:                 Map.entry(PetComponent.Mood.CALM, 0.15f)));
 3848:         table.put(PetComponent.Emotion.HIRAETH, weights(
 3849:                 Map.entry(PetComponent.Mood.SAUDADE, 0.60f),
 3850:                 Map.entry(PetComponent.Mood.RESTLESS, 0.30f),
 3851:                 Map.entry(PetComponent.Mood.CALM, 0.10f)));
 3852:         table.put(PetComponent.Emotion.STOIC, weights(
 3853:                 Map.entry(PetComponent.Mood.SISU, 0.4f),
 3854:                 Map.entry(PetComponent.Mood.CALM, 0.35f),
 3855:                 Map.entry(PetComponent.Mood.FOCUSED, 0.25f)));
 3856:         table.put(PetComponent.Emotion.HOPEFUL, weights(
 3857:                 Map.entry(PetComponent.Mood.CURIOUS, 0.3f),
 3858:                 Map.entry(PetComponent.Mood.HAPPY, 0.25f),
 3859:                 Map.entry(PetComponent.Mood.FOCUSED, 0.25f),
 3860:                 Map.entry(PetComponent.Mood.PASSIONATE, 0.2f)));
 3861:         table.put(PetComponent.Emotion.RELIEF, weights(
 3862:                 Map.entry(PetComponent.Mood.CALM, 0.45f),
 3863:                 Map.entry(PetComponent.Mood.HAPPY, 0.3f),
 3864:                 Map.entry(PetComponent.Mood.BONDED, 0.25f)));
 3865:         table.put(PetComponent.Emotion.GAMAN, weights(
 3866:                 Map.entry(PetComponent.Mood.SISU, 0.6f),
 3867:                 Map.entry(PetComponent.Mood.FOCUSED, 0.25f),
 3868:                 Map.entry(PetComponent.Mood.CALM, 0.15f)));
 3869:         table.put(PetComponent.Emotion.CURIOUS, weights(
 3870:                 Map.entry(PetComponent.Mood.CURIOUS, 0.6f),
 3871:                 Map.entry(PetComponent.Mood.PLAYFUL, 0.25f),
 3872:                 Map.entry(PetComponent.Mood.FOCUSED, 0.15f)));
 3873:         table.put(PetComponent.Emotion.SISU, weights(
 3874:                 Map.entry(PetComponent.Mood.SISU, 0.65f),
 3875:                 Map.entry(PetComponent.Mood.FOCUSED, 0.2f),
 3876:                 Map.entry(PetComponent.Mood.PASSIONATE, 0.15f)));
 3877:         table.put(PetComponent.Emotion.FOCUSED, weights(
 3878:                 Map.entry(PetComponent.Mood.FOCUSED, 0.65f),
 3879:                 Map.entry(PetComponent.Mood.SISU, 0.2f),
 3880:                 Map.entry(PetComponent.Mood.CURIOUS, 0.15f)));
 3881:         table.put(PetComponent.Emotion.PRIDE, weights(
 3882:                 Map.entry(PetComponent.Mood.PASSIONATE, 0.4f),
 3883:                 Map.entry(PetComponent.Mood.HAPPY, 0.2f),
 3884:                 Map.entry(PetComponent.Mood.BONDED, 0.2f),
 3885:                 Map.entry(PetComponent.Mood.FOCUSED, 0.2f)));
 3886:         table.put(PetComponent.Emotion.VIGILANT, weights(
 3887:                 Map.entry(PetComponent.Mood.PROTECTIVE, 0.4f),
 3888:                 Map.entry(PetComponent.Mood.AFRAID, 0.3f),
 3889:                 Map.entry(PetComponent.Mood.RESTLESS, 0.3f)));
 3890:         table.put(PetComponent.Emotion.WORRIED, weights(
 3891:                 Map.entry(PetComponent.Mood.AFRAID, 0.5f),
 3892:                 Map.entry(PetComponent.Mood.RESTLESS, 0.3f),
 3893:                 Map.entry(PetComponent.Mood.PROTECTIVE, 0.2f)));
 3894:         table.put(PetComponent.Emotion.PROTECTIVE, weights(
 3895:                 Map.entry(PetComponent.Mood.PROTECTIVE, 0.65f),
 3896:                 Map.entry(PetComponent.Mood.AFRAID, 0.2f),
 3897:                 Map.entry(PetComponent.Mood.BONDED, 0.15f)));
 3898:         table.put(PetComponent.Emotion.MELANCHOLY, weights(
 3899:                 Map.entry(PetComponent.Mood.SAUDADE, 0.55f),
 3900:                 Map.entry(PetComponent.Mood.CALM, 0.25f),
 3901:                 Map.entry(PetComponent.Mood.RESTLESS, 0.2f)));
 3902:         table.put(PetComponent.Emotion.CONTENT, weights(
 3903:                 Map.entry(PetComponent.Mood.CALM, 0.45f),
 3904:                 Map.entry(PetComponent.Mood.HAPPY, 0.3f),
 3905:                 Map.entry(PetComponent.Mood.BONDED, 0.25f)));
 3906:         table.put(PetComponent.Emotion.RESTLESS, weights(
 3907:                 Map.entry(PetComponent.Mood.RESTLESS, 0.6f),
 3908:                 Map.entry(PetComponent.Mood.CURIOUS, 0.2f),
 3909:                 Map.entry(PetComponent.Mood.AFRAID, 0.2f)));
 3910:         table.put(PetComponent.Emotion.NOSTALGIA, weights(
 3911:                 Map.entry(PetComponent.Mood.SAUDADE, 0.6f),
 3912:                 Map.entry(PetComponent.Mood.BONDED, 0.2f),
 3913:                 Map.entry(PetComponent.Mood.HAPPY, 0.2f)));
 3914:         table.put(PetComponent.Emotion.PLAYFULNESS, weights(
 3915:                 Map.entry(PetComponent.Mood.PLAYFUL, 0.65f),
 3916:                 Map.entry(PetComponent.Mood.HAPPY, 0.25f),
 3917:                 Map.entry(PetComponent.Mood.CURIOUS, 0.1f)));
 3918:         table.put(PetComponent.Emotion.LOYALTY, weights(
 3919:                 Map.entry(PetComponent.Mood.BONDED, 0.5f),
 3920:                 Map.entry(PetComponent.Mood.PROTECTIVE, 0.3f),
 3921:                 Map.entry(PetComponent.Mood.CALM, 0.2f)));
 3922:         
 3923:         // Ultra-rare emotion mappings
 3924:         table.put(PetComponent.Emotion.ECHOED_RESONANCE, weights(
 3925:                 Map.entry(PetComponent.Mood.ECHOED_RESONANCE, 0.70f),
 3926:                 Map.entry(PetComponent.Mood.SISU, 0.20f),
 3927:                 Map.entry(PetComponent.Mood.PROTECTIVE, 0.10f)));
 3928:         table.put(PetComponent.Emotion.ARCANE_OVERFLOW, weights(
 3929:                 Map.entry(PetComponent.Mood.ARCANE_OVERFLOW, 0.75f),
 3930:                 Map.entry(PetComponent.Mood.PASSIONATE, 0.15f),
 3931:                 Map.entry(PetComponent.Mood.CURIOUS, 0.10f)));
 3932:         table.put(PetComponent.Emotion.PACK_SPIRIT, weights(
 3933:                 Map.entry(PetComponent.Mood.PACK_SPIRIT, 0.70f),
 3934:                 Map.entry(PetComponent.Mood.BONDED, 0.20f),
 3935:                 Map.entry(PetComponent.Mood.PROTECTIVE, 0.10f)));
 3936: 
 3937:         return table;
 3939: 
 3940:     @SafeVarargs
 3942:         EnumMap<PetComponent.Mood, Float> map = new EnumMap<>(PetComponent.Mood.class);
 3943:         float total = 0f;
 3945:             float value = Math.max(0f, entry.getValue());
 3946:             map.put(entry.getKey(), value);
 3947:             total += value;
 3951:                 entry.setValue(entry.getValue() / total);
 3954:         return map;
 3956: 
 3958:         return RegistryJsonHelper.getObject(parent, key);
 3960: 
 3961:     // --------------------------------------------------------------------------------------------
 3962:     // Text rendering helpers (breathing/animation reused from previous implementation)
 3963:     // --------------------------------------------------------------------------------------------
 3964: 
 3966:         long currentTime = parent.getPet().getEntityWorld().getTime();
 3967:         int level = getMoodLevel();
 3968:         int updateInterval = getAnimationUpdateInterval(level);
 3969:         commitPendingPaletteIfReady(level, updateInterval, currentTime);
 3970:         boolean levelChanged = (cachedMoodText != null || cachedMoodTextWithDebug != null)
 3971:                 && !isCurrentLevelMatchingCache(level);
 3972:         boolean paletteChanged = lastRenderedPaletteGeneration != paletteGeneration;
 3973:         boolean needsUpdate = cachedMoodText == null
 3974:                 || cachedMoodTextWithDebug == null
 3975:                 || levelChanged
 3976:                 || paletteChanged
 3977:                 || (currentTime - lastTextUpdateTime) >= updateInterval;
 3979:             lastTextUpdateTime = currentTime;
 3980:             cachedMoodText = generateMoodText(false, level);
 3981:             cachedMoodTextWithDebug = generateMoodText(true, level);
 3982:             cachedLastLevel = level;
 3983:             lastRenderedPaletteGeneration = paletteGeneration;
 3985:         return withDebug ? cachedMoodTextWithDebug : cachedMoodText;
 3987: 
 3989:         return cachedLastLevel == level;
 3991: 
 3993:         PetComponent.Mood mood = getCurrentMood();
 3994:         boolean showEmotion = getMoodsBoolean("showDominantEmotion", false);
 3995:         String label = showEmotion ? getDominantEmotionName() : capitalize(mood.name());
 3996:         TextColor primaryColor = TextColor.fromFormatting(mood.primaryFormatting);
 3997:         TextColor secondaryColor = TextColor.fromFormatting(mood.secondaryFormatting);
 3998:         List<PetComponent.WeightedEmotionColor> palette = currentPaletteStops;
 3999: 
 4000:         boolean hasGradientPalette = palette != null && palette.size() >= 2;
 4001: 
 4002:         Text baseText = hasGradientPalette
 4004:                     case 0 -> createStaticPaletteText(label, palette, primaryColor);
 4005:                     case 1 -> createBreathingText(label, palette, primaryColor, secondaryColor, 1);
 4006:                     case 2 -> createBreathingGradient(label, palette, primaryColor, secondaryColor, 2);
 4007:                     case 3 -> createBreathingMovingGradient(label, palette, primaryColor, secondaryColor, 3);
 4008:                     default -> createBreathingMovingGradient(label, palette, primaryColor, secondaryColor, level);
 4010:                 : createGentleSingleStopText(label, palette, primaryColor, secondaryColor, level);
 4011: 
 4013:             return baseText;
 4015:         
 4016:         // Enhanced debug output showing emotional buildup system
 4017:         MutableText debugText = baseText.copy();
 4018:         debugText.append(Text.literal(" [" + level + "]").styled(s -> s.withColor(TextColor.fromFormatting(Formatting.GRAY))));
 4019:         
 4020:         // Show buildup metrics
 4021:         float currentStrength = moodBlend.getOrDefault(currentMood, 0f);
 4022:         float buildupMult = computeBuildupMultiplier(currentMood, currentStrength);
 4023:         int activeEmotionCount = (int) emotionRecords.values().stream()
 4024:             .filter(r -> r.intensity > EPSILON)
 4025:             .count();
 4026:         
 4027:         debugText.append(Text.literal(" (s:" + String.format("%.2f", currentStrength))
 4028:             .styled(s -> s.withColor(TextColor.fromFormatting(Formatting.DARK_GRAY))));
 4029:         
 4031:             Formatting buildupColor = buildupMult > 1.0f ? Formatting.GREEN : Formatting.YELLOW;
 4032:             debugText.append(Text.literal(" b:" + String.format("%.2f", buildupMult))
 4033:                 .styled(s -> s.withColor(TextColor.fromFormatting(buildupColor))));
 4035:         
 4037:             debugText.append(Text.literal(" e:" + activeEmotionCount)
 4038:                 .styled(s -> s.withColor(TextColor.fromFormatting(Formatting.AQUA))));
 4040:         
 4041:         debugText.append(Text.literal(")")
 4042:             .styled(s -> s.withColor(TextColor.fromFormatting(Formatting.DARK_GRAY))));
 4043:         
 4044:         return debugText;
 4046: 
 4048:         TextColor paletteColor = (palette == null || palette.isEmpty()) ? fallbackPrimary : palette.get(0).color();
 4049:         float emphasis = (palette == null || palette.isEmpty()) ? 0f : 0.85f;
 4050:         TextColor finalColor = blendWithFallback(fallbackPrimary, paletteColor, emphasis);
 4051:         return Text.literal(text).styled(s -> s.withColor(finalColor));
 4053: 
 4054:     private MutableText createBreathingText(String text,
 4055:             List<PetComponent.WeightedEmotionColor> palette,
 4057:         long worldTime = parent.getPet().getEntityWorld().getTime();
 4058:         int breathingSpeed = computeBreathingDuration(level, BASE_BREATHING_SPEEDS);
 4059:         int updateInterval = getAnimationUpdateInterval(level);
 4060:         long animationTime = (worldTime / updateInterval) * updateInterval;
 4061:         double breathingPhase = (animationTime % breathingSpeed) / (double) breathingSpeed;
 4062:         double breathingIntensity = (Math.sin(breathingPhase * 2 * Math.PI) + 1) / 2;
 4065:         int levelIndex = Math.min(level - 1, minIntensities.length - 1);
 4066:         double minIntensity = minIntensities[levelIndex];
 4067:         double maxIntensity = maxIntensities[levelIndex];
 4068:         double scaledIntensity = minIntensity + (breathingIntensity * (maxIntensity - minIntensity));
 4069:         MutableText out = Text.empty();
 4070:         char[] chars = text.toCharArray();
 4072:             double charPhase = (i * 0.4) + (breathingPhase * 1.5);
 4073:             double charBreathing = (Math.sin(charPhase) + 1) / 2;
 4074:             double finalIntensity = (scaledIntensity + charBreathing * 0.3) / 1.3;
 4075:             TextColor base = finalIntensity > 0.5 ? fallbackSecondary : fallbackPrimary;
 4076:             float gradientAnchor = MathHelper.clamp(
 4077:                     (float) ((breathingPhase * 0.45) + (i / (float) Math.max(1, chars.length - 1)) * 0.55
 4078:                             + charBreathing * 0.1),
 4079:                     0f, 1f);
 4080:             TextColor paletteColor = PetComponent.sampleEmotionPalette(palette, gradientAnchor, base);
 4081:             float emphasis = MathHelper.clamp(0.55f + (float) finalIntensity * 0.35f, 0f, 1f);
 4082:             TextColor finalColor = blendWithFallback(base, paletteColor, emphasis);
 4083:             out.append(Text.literal(String.valueOf(chars[i])).styled(s -> s.withColor(finalColor)));
 4085:         return out;
 4087: 
 4088:     private MutableText createBreathingGradient(String text,
 4089:             List<PetComponent.WeightedEmotionColor> palette,
 4091:         long worldTime = parent.getPet().getEntityWorld().getTime();
 4092:         int breathingSpeed = computeBreathingDuration(level, BASE_GRADIENT_SPEEDS);
 4093:         int updateInterval = getAnimationUpdateInterval(level);
 4094:         long animationTime = (worldTime / updateInterval) * updateInterval;
 4095:         double breathingPhase = (animationTime % breathingSpeed) / (double) breathingSpeed;
 4096:         double breathingIntensity = (Math.sin(breathingPhase * 2 * Math.PI) + 1) / 2;
 4097:         MutableText out = Text.empty();
 4098:         char[] chars = text.toCharArray();
 4100:             double charPhase = (i * 0.45) + breathingPhase * 1.1;
 4101:             double charBreathing = (Math.sin(charPhase) + 1) / 2;
 4102:             double blend = (breathingIntensity * 0.6 + charBreathing * 0.4);
 4103:             TextColor base = UIStyle.interpolateColor(fallbackPrimary, fallbackSecondary, MathHelper.clamp((float) blend, 0f, 1f));
 4104:             float gradientAnchor = MathHelper.clamp(
 4105:                     (float) (breathingPhase * 0.35 + (i / (float) Math.max(1, chars.length - 1)) * 0.65),
 4106:                     0f, 1f);
 4107:             TextColor paletteColor = PetComponent.sampleEmotionPalette(palette, gradientAnchor, base);
 4108:             float emphasis = MathHelper.clamp(0.6f + (float) blend * 0.35f, 0f, 1f);
 4109:             TextColor finalColor = blendWithFallback(base, paletteColor, emphasis);
 4110:             out.append(Text.literal(String.valueOf(chars[i])).styled(s -> s.withColor(finalColor)));
 4112:         return out;
 4114: 
 4115:     private MutableText createBreathingMovingGradient(String text,
 4116:             List<PetComponent.WeightedEmotionColor> palette,
 4118:         long worldTime = parent.getPet().getEntityWorld().getTime();
 4119:         int breathingSpeed = computeBreathingDuration(level, BASE_SHIMMER_SPEEDS);
 4120:         int updateInterval = getAnimationUpdateInterval(level);
 4121:         long animationTime = (worldTime / updateInterval) * updateInterval;
 4122:         double breathingPhase = (animationTime % breathingSpeed) / (double) breathingSpeed;
 4123:         MutableText out = Text.empty();
 4124:         char[] chars = text.toCharArray();
 4126:             double wave = Math.sin((i * 0.6) + (breathingPhase * 2 * Math.PI));
 4127:             double mix = (wave + 1) / 2;
 4128:             double shimmer = (Math.sin((breathingPhase * 2 * Math.PI) + i * 0.25) + 1) / 2;
 4129:             TextColor base = UIStyle.interpolateColor(fallbackPrimary, fallbackSecondary, MathHelper.clamp((float) mix, 0f, 1f));
 4130:             float gradientAnchor = MathHelper.clamp((float) (mix * 0.5 + shimmer * 0.5), 0f, 1f);
 4131:             TextColor paletteColor = PetComponent.sampleEmotionPalette(palette, gradientAnchor, base);
 4132:             float emphasis = MathHelper.clamp(0.65f + (float) shimmer * 0.3f, 0f, 1f);
 4133:             TextColor finalColor = blendWithFallback(base, paletteColor, emphasis);
 4134:             out.append(Text.literal(String.valueOf(chars[i])).styled(s -> s.withColor(finalColor)));
 4136:         return out;
 4138: 
 4139:     private Text createGentleSingleStopText(String text,
 4140:             List<PetComponent.WeightedEmotionColor> palette,
 4142:         TextColor paletteColor = (palette == null || palette.isEmpty()) ? null : palette.get(0).color();
 4143:         TextColor softenedBase = paletteColor != null
 4144:                 ? blendWithFallback(fallbackPrimary, paletteColor, 0.4f)
 4145:                 : fallbackPrimary;
 4146: 
 4147:         int safeLevel = Math.max(level, 0);
 4149:             return Text.literal(text).styled(style -> style.withColor(softenedBase));
 4151: 
 4152:         return createGentleSingleStopBreathing(text, softenedBase, fallbackSecondary, safeLevel);
 4154: 
 4155:     private MutableText createGentleSingleStopBreathing(String text, TextColor baseColor,
 4157:         long worldTime = parent.getPet().getEntityWorld().getTime();
 4158:         int breathingSpeed = computeBreathingDuration(Math.max(level, 1), BASE_BREATHING_SPEEDS);
 4159:         int updateInterval = getAnimationUpdateInterval(Math.max(level, 1));
 4160:         long animationTime = (worldTime / updateInterval) * updateInterval;
 4161:         double breathingPhase = (animationTime % breathingSpeed) / (double) breathingSpeed;
 4162:         double breathingIntensity = (Math.sin(breathingPhase * 2 * Math.PI) + 1) / 2;
 4163: 
 4166:         int levelIndex = Math.min(Math.max(level, 1) - 1, minIntensities.length - 1);
 4167:         double minIntensity = minIntensities[levelIndex];
 4168:         double maxIntensity = maxIntensities[levelIndex];
 4169:         double scaledIntensity = minIntensity + (breathingIntensity * (maxIntensity - minIntensity));
 4170: 
 4171:         TextColor lightenTarget = UIStyle.interpolateColor(baseColor, TextColor.fromRgb(0xFFFFFF), 0.25f);
 4172:         TextColor darkenTarget = UIStyle.interpolateColor(baseColor, TextColor.fromRgb(0x000000), 0.18f);
 4173:         TextColor accentBase = fallbackSecondary != null
 4174:                 ? UIStyle.interpolateColor(baseColor, fallbackSecondary, 0.15f)
 4175:                 : baseColor;
 4176: 
 4177:         MutableText out = Text.empty();
 4178:         char[] chars = text.toCharArray();
 4180:             double charPhase = (i * 0.35) + (breathingPhase * 1.2);
 4181:             double charBreathing = (Math.sin(charPhase) + 1) / 2;
 4182:             double finalPulse = (scaledIntensity + charBreathing * 0.2) / 1.2;
 4183:             float pulseBlend = MathHelper.clamp((float) finalPulse, 0f, 1f);
 4184:             TextColor gentleHighlight = UIStyle.interpolateColor(accentBase, lightenTarget, pulseBlend * 0.6f);
 4185:             TextColor finalColor = UIStyle.interpolateColor(darkenTarget, gentleHighlight, pulseBlend);
 4186:             out.append(Text.literal(String.valueOf(chars[i])).styled(s -> s.withColor(finalColor)));
 4188:         return out;
 4190: 
 4193:             return fallback;
 4195:         emphasis = MathHelper.clamp(emphasis, 0f, 1f);
 4196:         return UIStyle.interpolateColor(fallback, paletteColor, emphasis);
 4198: 
 4200:         ensureConfigCache();
 4201:         // Progressive acceleration: higher levels update faster for more dynamic visuals
 4202:         // Level 0: base interval (slow)
 4203:         // Level 1: slightly faster
 4204:         // Level 2: noticeably faster
 4205:         // Level 3: very fast, dramatic
 4206:         double speedScale = 1.0 - (Math.min(level, 3) * cachedAnimationSpeedMultiplier);
 4207:         speedScale = MathHelper.clamp(speedScale, 0.25, 1.0); // Never slower than 1/4 base speed
 4208:         double interval = cachedBaseAnimationUpdateInterval * speedScale;
 4209:         int result = (int) Math.round(interval);
 4210:         return Math.max(cachedMinAnimationInterval, Math.min(cachedMaxAnimationInterval, result));
 4212: 
 4214:         ensureConfigCache();
 4216:             return defaultValue;
 4218:         JsonElement element = cachedMoodsSection.get(key);
 4220:             return defaultValue;
 4222:         return element.getAsBoolean();
 4224: 
 4227:             return value;
 4229:         String lower = value.toLowerCase();
 4230:         return Character.toUpperCase(lower.charAt(0)) + lower.substring(1);
 4232: 
 4234:         return capitalize(value.replace('_', ' '));
 4236: 
 4238:         opponentPairs.clear();
 4239:         registerOpponentPair(PetComponent.Emotion.ANGST, PetComponent.Emotion.CHEERFUL);
 4240:         registerOpponentPair(PetComponent.Emotion.FOREBODING, PetComponent.Emotion.LAGOM);
 4241:         registerOpponentPair(PetComponent.Emotion.STARTLE, PetComponent.Emotion.RELIEF);
 4242:         registerOpponentPair(PetComponent.Emotion.FRUSTRATION, PetComponent.Emotion.PLAYFULNESS);
 4243:         registerOpponentPair(PetComponent.Emotion.REGRET, PetComponent.Emotion.HOPEFUL);
 4244:         registerOpponentPair(PetComponent.Emotion.SAUDADE, PetComponent.Emotion.CONTENT);
 4245:         registerOpponentPair(PetComponent.Emotion.DISGUST, PetComponent.Emotion.UBUNTU);
 4246:         registerOpponentPair(PetComponent.Emotion.STOIC, PetComponent.Emotion.CHEERFUL);
 4248: 
 4250:         buildDefaultOpponentPairs();
 4252:             return;
 4255:             PetComponent.Emotion source;
 4257:                 source = PetComponent.Emotion.valueOf(emotionKey.toUpperCase());
 4259:                 continue;
 4261:             JsonElement element = cachedOpponentSection.get(emotionKey);
 4263:                 continue;
 4265:             @SuppressWarnings("unused") // Set is populated via computeIfAbsent, used indirectly
 4266:             EnumSet<PetComponent.Emotion> set = opponentPairs.computeIfAbsent(source, s -> EnumSet.noneOf(PetComponent.Emotion.class));
 4269:                     return;
 4271:                 String targetName = jsonElement.getAsString().toUpperCase();
 4273:                     PetComponent.Emotion target = PetComponent.Emotion.valueOf(targetName);
 4274:                     registerOpponentPair(source, target);
 4280: 
 4282:         opponentPairs.computeIfAbsent(a, key -> EnumSet.noneOf(PetComponent.Emotion.class)).add(b);
 4283:         opponentPairs.computeIfAbsent(b, key -> EnumSet.noneOf(PetComponent.Emotion.class)).add(a);
 4285: 
 4286:     // --------------------------------------------------------------------------------------------
 4287:     // Supporting data structures
 4288:     // --------------------------------------------------------------------------------------------
 4289: 
 4291:         final PetComponent.Emotion emotion;
 4292:         float intensity = DEFAULT_INTENSITY;
 4293:         float impactBudget = 0f;
 4294:         float cadenceEMA = 0f;
 4295:         float volatilityEMA = 0f;
 4296:         float peakEMA = 0f;
 4297:         float habituationSlope = HABITUATION_BASE;
 4298:         float sensitisationGain = 1.0f;
 4299:         float homeostasisBias = 1.0f;
 4300:         float contagionShare = 0f;
 4301:         float relationshipGuard = RELATIONSHIP_BASE;
 4302:         float dangerWindow = DANGER_BASE;
 4303:         float appraisalConfidence = APPRAISAL_BASE;
 4304:         float weight = 0f;
 4305:         long startTime;
 4306:         long lastEventTime;
 4307:         long lastUpdateTime;
 4308: 
 4310:             this.emotion = emotion;
 4311:             this.startTime = now;
 4312:             this.lastEventTime = now;
 4313:             this.lastUpdateTime = now;
 4315: 
 4318:                 return;
 4320:             float delta = Math.max(0f, now - lastUpdateTime);
 4321:             float cadence = cadenceEMA > 0f ? cadenceEMA : engine.cachedHabituationBase;
 4322:             float adaptiveHalf = MathHelper.clamp(cadence * engine.cachedHalfLifeMultiplier, engine.cachedMinHalfLife, engine.cachedMaxHalfLife);
 4323:             
 4324:             String emotionKey = emotion.name().toLowerCase();
 4325:             float emotionMultiplier = engine.cachedEmotionDecayMultipliers.getOrDefault(emotionKey, 1.0f);
 4326:             adaptiveHalf *= emotionMultiplier;
 4327:             
 4329:                 adaptiveHalf *= engine.cachedNegativePersistence;
 4331:             
 4333:                 adaptiveHalf *= engine.cachedConditionPresentMultiplier;
 4335:             
 4336:             float decayRate = (float) (Math.log(2) / adaptiveHalf);
 4337:             float decay = (float) Math.exp(-decayRate * delta);
 4338:             intensity *= decay;
 4339:             impactBudget *= decay;
 4340:             
 4341:             homeostasisBias = MathHelper.lerp((float) Math.exp(-delta / engine.cachedHomeostasisRecoveryHalf), homeostasisBias, 1.1f);
 4342:             contagionShare *= Math.exp(-delta / 400f);
 4343:             lastUpdateTime = now;
 4346: 
 4347:     // ===== LEVEL TRACKING & BUILDUP SYSTEM =====
 4348:     
 4350:         final int level;
 4351:         final long timestamp;
 4352:         
 4354:             this.level = level;
 4355:             this.timestamp = timestamp;
 4358:     
 4360:         float[] specific = perMoodThresholds.get(mood);
 4361:         return specific != null ? specific : getLevelThresholds();
 4363:     
 4364:     /**
 4365:      * Compute buildup multiplier based on emotional momentum.
 4366:      * Rising emotions get boosted (feels responsive), falling get gentle resistance.
 4367:      * This creates a "feeling the buildup" experience where escalating emotions accelerate.
 4368:      */
 4371:             return 1.0f;
 4373: 
 4375:             return 1.0f;
 4377: 
 4378:         // Need at least one previous reading for this mood to compare
 4380:             return 1.0f;  // First update or mood switch, no trend available
 4382:         
 4383:         // Calculate trend: positive = rising, negative = falling
 4384:         float trend = currentStrength - previousMoodStrength;
 4385:         
 4386:         // Nature modifiers: volatile pets escalate faster, calm pets slower
 4387:         float volatilityMod = parent.getNatureVolatilityMultiplier(); // 0.5-1.5 range
 4388:         float resilienceMod = parent.getNatureResilienceMultiplier();  // 0.5-1.5 range
 4389:         
 4390:         // Only apply multiplier if trend is significant (avoid noise)
 4392:             // Rising emotion: BOOST toward next level (responsive, exciting)
 4393:             // Volatile natures escalate faster, resilient slower
 4394:             float risingMult = BUILDUP_RISING_MULTIPLIER * volatilityMod;
 4395:             return MathHelper.clamp(risingMult, 1.0f, 1.5f);
 4397:             // Falling emotion: gentle resistance (prevents whiplash, smooth decay)
 4398:             // Resilient natures recover faster
 4399:             float fallingMult = BUILDUP_FALLING_MULTIPLIER * (2.0f - resilienceMod);
 4400:             return MathHelper.clamp(fallingMult, 0.7f, 1.0f);
 4402:         
 4403:         // Steady state or minor fluctuation: normal scaling
 4404:         return 1.0f;
 4406:     
 4407:     /**
 4408:      * Apply hysteresis to level transitions to prevent jitter.
 4409:      * Requires extra push to go UP (progressive resistance), less to go DOWN (smooth decay).
 4410:      * Uses effectiveStrength which already includes buildup multiplier.
 4411:      * 
 4412:      * @param rawLevel The level calculated from thresholds
 4413:      * @param effectiveStrength The mood strength after buildup multiplier (0-1)
 4414:      * @param thresholds The threshold array for current mood
 4415:      * @return The final level after hysteresis
 4416:      */
 4418:         // No previous level data or no change - skip hysteresis
 4420:             return rawLevel;
 4422: 
 4424:             // GOING UP: need to exceed threshold by extra margin (creates "earning it" feel)
 4425:             // The threshold we're trying to cross is at index (rawLevel - 1)
 4426:             int thresholdIndex = rawLevel - 1;
 4427:             
 4428:             // Bounds check: ensure valid threshold index
 4430:                 return rawLevel;  // Edge case: trust the raw calculation
 4432:             
 4433:             float crossingThreshold = thresholds[thresholdIndex];
 4434:             
 4435:             // Progressive resistance: harder to reach higher levels
 4436:             // Level 0→1: +0.03+0.02 = 0.05 margin
 4437:             // Level 1→2: +0.03+0.04 = 0.07 margin  
 4438:             // Level 2→3: +0.03+0.06 = 0.09 margin (hardest!)
 4439:             float requiredMargin = 0.03f + (0.02f * rawLevel);
 4440:             float actualMargin = effectiveStrength - crossingThreshold;
 4441:             
 4443:                 // Not enough push - stay at current level
 4444:                 return lastLevel;
 4447:             // GOING DOWN: need to fall below threshold by small margin (easier than going up)
 4448:             // The threshold we're falling below is at index (lastLevel - 1)
 4449:             int thresholdIndex = lastLevel - 1;
 4450:             
 4451:             // Bounds check
 4453:                 return rawLevel;  // Edge case: trust the raw calculation
 4455:             
 4456:             float crossingThreshold = thresholds[thresholdIndex];
 4457:             
 4458:             // Small margin prevents rapid oscillation but allows smooth decay
 4459:             float requiredMargin = 0.02f;
 4460:             float actualMargin = crossingThreshold - effectiveStrength;
 4461:             
 4463:                 // Haven't fallen enough - stay at current level
 4464:                 return lastLevel;
 4467: 
 4468:         // Passed hysteresis checks - commit to new level
 4469:         return rawLevel;
 4471:     
 4472:     /**
 4473:      * Update level history for habituation tracking.
 4474:      * Tracks time spent at high levels to add resistance if camping at level 2-3.
 4475:      * Optimized for O(1) amortized cost by using incremental updates.
 4476:      */
 4478:         // Incremental update: calculate contribution of the period we're adding
 4480:             LevelSnapshot last = levelHistory.getLast();
 4481:             long periodDuration = now - last.timestamp;
 4482:             
 4483:             // If previous level was 2-3, add this period to high-level time
 4485:                 recentLevel23Time += periodDuration;
 4488:         
 4489:         // Add new snapshot
 4490:         levelHistory.add(new LevelSnapshot(currentLevel, now));
 4491:         
 4492:         // Trim old entries and adjust high-level time accordingly
 4494:             LevelSnapshot removed = levelHistory.removeFirst();
 4495:             
 4496:             // Subtract the removed period from high-level time if it was level 2-3
 4498:                 LevelSnapshot nextAfterRemoved = levelHistory.getFirst();
 4499:                 long removedPeriod = nextAfterRemoved.timestamp - removed.timestamp;
 4500:                 
 4502:                     recentLevel23Time = Math.max(0f, recentLevel23Time - removedPeriod);
 4507:     
 4508:     /**
 4509:      * Get habituation drag - reduces strength if pet has been at high levels too long.
 4510:      * Prevents "ceiling camping" where pets stay at level 3 constantly.
 4511:      */
 4512:     @SuppressWarnings("unused")
 4515:             return 0f;  // Not enough history yet
 4517:         
 4518:         // Calculate what fraction of recent time was spent at level 2-3
 4519:         long totalTime = 0;
 4521:             totalTime = levelHistory.getLast().timestamp - levelHistory.getFirst().timestamp;
 4523:         
 4525:             return 0f;
 4527:         
 4528:         float highLevelRatio = recentLevel23Time / Math.max(1f, totalTime);
 4529:         
 4530:         // If spent >50% of recent time at high levels, add resistance
 4532:             return 0.10f * (highLevelRatio - 0.5f);  // Max -0.05 penalty
 4534:         
 4535:         return 0f;
 4537: 
 4539:         final EmotionRecord record;
 4540:         final float freshness;
 4541:         final float frequency;
 4542:         float signal;
 4543: 
 4545:             this.record = record;
 4546:             this.freshness = freshness;
 4547:             this.frequency = frequency;
 4548:             this.signal = signal;
 4551: 
 4555: 
 4556: 
 4557: 
